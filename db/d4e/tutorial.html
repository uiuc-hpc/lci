<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LCI: Tutorial</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/uiuc-hpc/lci" class="github-corner" title="View source on GitHub" target="_blank" rel="noopener noreferrer">
  <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
  <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LCI<span id="projectnumber">&#160;v2.0.0-dev</span>
   </div>
   <div id="projectbrief">For Asynchronous Multithreaded Communication</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('db/d4e/tutorial.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#autotoc_md42">Add LCI to your project</a>
  </li>
  <li class="level1">
    <a href="#autotoc_md43">Install LCI</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md44">Prerequisites</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md45">With CMake</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md46">Install LCI on your laptop</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md47">Install LCI on a cluster</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md48">Important CMake variables</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#autotoc_md49">With Spack</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md50">Important Spack variables</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#autotoc_md51">Cluster-specific Installation Note</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md52">NCSA Delta</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md53">NCSA DeltaAI</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md54">SDSC Expanse</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md55">NERSC Perlmutter</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md56">TACC Frontera</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md57">Write LCI programs</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md58">Overview</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md59">Objectified Flexible Functions (OFF)</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md60">Resource Management</a>
            <ul>
              <li class="level4 empty">
                <ul>
                  <li class="level5">
                    <a href="#autotoc_md61">Runtime</a>
                  </li>
                  <li class="level5">
                    <a href="#autotoc_md62">Device</a>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li class="level3">
            <a href="#autotoc_md63">Communication Posting</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md64">Completion Checking</a>
            <ul>
              <li class="level4">
                <a href="#autotoc_md65">Synchronizer</a>
              </li>
              <li class="level4">
                <a href="#autotoc_md66">Completion Queue</a>
              </li>
              <li class="level4">
                <a href="#autotoc_md67">Handler</a>
              </li>
              <li class="level4">
                <a href="#autotoc_md68">Graph (Advanced)</a>
              </li>
            </ul>
          </li>
          <li class="level3">
            <a href="#autotoc_md69">Progress</a>
            <ul>
              <li class="level4 empty">
                <ul>
                  <li class="level5">
                    <a href="#autotoc_md70">Basic Usage</a>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#autotoc_md71">Other Materials</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md72">Examples</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md73">Hello World</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md74">Hello World (Active Message)</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md75">Distributed Array</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md76">Non-blocking Barrier</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md77">Multithreaded Active Message Ping-pong</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md78">Run LCI applications</a>
    <ul>
      <li class="level2 empty">
        <ul>
          <li class="level3">
            <a href="#autotoc_md79">Run LCI applications with lcrun</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md80">Run LCI applications with srun</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md81">Run LCI applications with mpirun</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#autotoc_md82">More details</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md83">Bootstrapping backends</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md84">Launchers</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md85">More about the file backend</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md42"></a>
Add LCI to your project</h1>
<p>The following CMake code will add LCI to your project. It will first try to find LCI on your system. If it is not found, it will download and build LCI from GitHub.</p>
<div class="fragment"><div class="line"># Try to find LCI externally</div>
<div class="line">find_package(</div>
<div class="line">  LCI</div>
<div class="line">  CONFIG</div>
<div class="line">  PATH_SUFFIXES</div>
<div class="line">  lib/cmake</div>
<div class="line">  lib64/cmake)</div>
<div class="line">if(NOT LCI_FOUND)</div>
<div class="line">  message(STATUS &quot;Existing LCI installation not found. Try FetchContent.&quot;)</div>
<div class="line">  include(FetchContent)</div>
<div class="line">  FetchContent_Declare(</div>
<div class="line">    lci</div>
<div class="line">    GIT_REPOSITORY https://github.com/uiuc-hpc/lci.git</div>
<div class="line">    GIT_TAG master)</div>
<div class="line">  FetchContent_MakeAvailable(lci)</div>
<div class="line">endif()</div>
<div class="line"> </div>
<div class="line"># Link LCI to your target</div>
<div class="line">target_link_libraries(your_target PRIVATE LCI::lci)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md43"></a>
Install LCI</h1>
<p>Although CMake FetchContent is convenient, you may also want to install LCI on your systems.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
Prerequisites</h2>
<ul>
<li>A Linux or MacOS laptop or cluster.</li>
<li>A C++ compiler that supports C++17 or higher (GCC 8 or higher, Clang 5 or higher, etc).</li>
<li>CMake 3.12 or higher.</li>
<li>A network backend that supports LCI. Currently, LCI supports:<ul>
<li><a href="https://github.com/linux-rdma/rdma-core/blob/master/Documentation/libibverbs.md">libibverbs</a>. Typically for Infiniband/RoCE.</li>
<li><a href="https://ofiwg.github.io/libfabric/">libfabric</a>. For Slingshot-11, Ethernet, shared memory (including laptop), and other networks.</li>
</ul>
</li>
</ul>
<p>Normal clusters should already have these installed (you may need a few <code>module load</code>). If you are using a laptop, you may need to install cmake and libfabric manually.</p><ul>
<li>For Ubuntu, you can install the prerequisites using: <div class="fragment"><div class="line">sudo apt-get install -y cmake libfabric-bin libfabric-dev</div>
</div><!-- fragment --></li>
<li>For MacOS, you can install the prerequisites using: <div class="fragment"><div class="line">brew install cmake libfabric</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md45"></a>
With CMake</h2>
<h3><a class="anchor" id="autotoc_md46"></a>
Install LCI on your laptop</h3>
<div class="fragment"><div class="line">git clone https://github.com/uiuc-hpc/lci.git</div>
<div class="line">cd lci</div>
<div class="line">mkdir build</div>
<div class="line">cmake -DCMAKE_INSTALL_PREFIX=/path/to/install -DLCI_NETWORK_BACKENDS=ofi ..</div>
<div class="line">make</div>
<div class="line">make install</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md47"></a>
Install LCI on a cluster</h3>
<div class="fragment"><div class="line">git clone https://github.com/uiuc-hpc/lci.git</div>
<div class="line">cd lci</div>
<div class="line">mkdir build</div>
<div class="line">cmake -DCMAKE_INSTALL_PREFIX=/path/to/install ..</div>
<div class="line">make</div>
<div class="line">make install</div>
</div><!-- fragment --><p> Basically the same as installing LCI on your laptop, but you don't need to install pre-requisites because they are already installed on the cluster. You also don't need to manually select the network backend because LCI will automatically select the best one for you.</p>
<h3><a class="anchor" id="autotoc_md48"></a>
Important CMake variables</h3>
<ul>
<li><code>LCI_DEBUG=[ON|OFF]</code>: Enable/disable the debug mode (more assertions and logs). The default value is <code>OFF</code>.</li>
<li><code>LCI_NETWORK_BACKENDS=[ibv|ofi]</code>: allow multiple values separated with comma. Hint to which network backend to use. If the backend indicated by this variable are found, LCI will just use it. Otherwise, LCI will use whatever are found with the priority <code>ibv</code> &gt; <code>ofi</code>. The default value is <code>ibv,ofi</code>. Typically, you don't need to modify this variable as if <code>libibverbs</code> presents, it is likely to be the recommended one to use.<ul>
<li><code>ibv</code>: <a href="https://github.com/linux-rdma/rdma-core/blob/master/Documentation/libibverbs.md">libibverbs</a>, typically for infiniband/RoCE.</li>
<li><code>ofi</code>: <a href="https://ofiwg.github.io/libfabric/">libfabric</a>, for all other networks (slingshot-11, ethernet, shared memory).</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md49"></a>
With Spack</h2>
<p>LCI can be installed using <a href="https://spack.io/">Spack</a>. An LCI recipe has been included in the Spack official repository. For the most up-to-date version, you can also use the recipe in the <code>contrib/spack</code> directory of the LCI repository. To install LCI using Spack, run the following commands:</p>
<div class="fragment"><div class="line"># Assume you have already installed Spack</div>
<div class="line"># Optional: add the LCI spack recipe from the LCI repository</div>
<div class="line">git clone https://github.com/uiuc-hpc/lci.git</div>
<div class="line">spack repo add lci/contrib/spack</div>
<div class="line">spack install lci</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md50"></a>
Important Spack variables</h3>
<ul>
<li><code>debug</code>: define the CMake variable <code>LCI_DEBUG</code>.</li>
<li><code>backend=[ibv|ofi]</code>: define the CMake variable <code>LCI_NETWORK_BACKENDS</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md51"></a>
Cluster-specific Installation Note</h2>
<h3><a class="anchor" id="autotoc_md52"></a>
NCSA Delta</h3>
<details >
<summary >
Click to expand</summary>
<p></p>
<p>tl;dr: <code>module load libfabric</code>, then specify the cmake variable <code>-DLCI_NETWORK_BACKENDS=ofi</code> or the Spack variable <code>backend=ofi</code> when building LCI.</p>
<p>The only caveat is that you need to pass the -DLCI_NETWORK_BACKENDS=ofi option to CMake. This is because Delta somehow has both libibverbs and libfabric installed, but only libfabric is working.</p>
<p>No additional <code>srun</code> arguments are needed to run LCI applications. However, we have noticed that <code>srun</code> can be broken under some mysterious module loading conditions. In such case, just use <code>srun --mpi=pmi2</code> instead. </p>
</details>
<h3><a class="anchor" id="autotoc_md53"></a>
NCSA DeltaAI</h3>
<details >
<summary >
Click to expand</summary>
<p></p>
<p>Use <code>srun --mpi=pmi2</code> or <code>srun --mpi=pmix</code> to run LCI applications.</p>
<p>(Experimental feature: you can try passing <code>-DLCI_USE_CUDA</code> to CMake to enable GPU direct communication.) </p>
</details>
<h3><a class="anchor" id="autotoc_md54"></a>
SDSC Expanse</h3>
<details >
<summary >
Click to expand</summary>
<p>tl;dr: use <code>srun --mpi=pmi2</code> to run LCI applications.</p>
<p>You don't need to do anything special to install LCI on Expanse. Just follow the instructions above. </p>
</details>
<h3><a class="anchor" id="autotoc_md55"></a>
NERSC Perlmutter</h3>
<details >
<summary >
Click to expand</summary>
<p>tl;dr: <code>module load cray-pmi</code> before running the CMake command. Add cray-pmi as a Spack external package and add <code>default-pm=cray</code> when building LCI with <code>spack install</code>.</p>
<p>LCI needs to find the Perlmutter-installed Cray-PMI library. Do <code>module load cray-pmi</code> and then run the CMake command to configure LCI. Make sure you see something like this in the output: </p><div class="fragment"><div class="line">-- Found PMI: /opt/cray/pe/pmi/6.1.15/lib/libpmi.so  </div>
<div class="line">-- Found PMI2: /opt/cray/pe/pmi/6.1.15/lib/libpmi2.so</div>
</div><!-- fragment --><p>When building LCI with <code>spack install</code>, you need to first add cray-pmi as a Spack external package. Put the following code in <code>~/.spack/packages.yaml</code>: </p><div class="fragment"><div class="line">cray-pmi:</div>
<div class="line">    externals:</div>
<div class="line">    - spec: cray-pmi@6.1.15</div>
<div class="line">      modules:</div>
<div class="line">      - cray-pmi/6.1.15</div>
<div class="line">    buildable: false</div>
</div><!-- fragment --><p> Afterwards, you can use <code>spack install lci default-pm=cray</code>. </p>
</details>
<h3><a class="anchor" id="autotoc_md56"></a>
TACC Frontera</h3>
<details >
<summary >
Click to expand</summary>
<p>tl;dr: use <code>ibrun</code> and the MPI bootstrap backend in LCI.</p>
<p>Frontera recommends using its <code>ibrun</code> command to launch multi-node applications, and its <code>ibrun</code> is tightly coupled with its MPI installation. Therefore, the recommended way to run LCI applications on Frontera is to use the MPI bootstrap backend. You can do this by setting the CMake variable <code>LCT_PMI_BACKEND_ENABLE_MPI=ON</code> and linking LCI to the MPI library.</p>
<p>It is also possible to directly use its <code>srun</code> and the PMI2 bootstrap backend in LCI. However, we found that this method can result in very slow bootstrapping times for large numbers of ranks (&gt;=512). </p>
</details>
<h1><a class="anchor" id="autotoc_md57"></a>
Write LCI programs</h1>
<h2><a class="anchor" id="autotoc_md58"></a>
Overview</h2>
<p>LCI is a C++ library that is implemented in C++17 but its public header is compatible with C++11 and later versions. A C API is plannedâ€”please open an issue if you need it. The LCI API is structured into four core components:</p>
<ul>
<li>Resource Management: Allocation and deallocation of LCI resources.</li>
<li>Communication Posting: Posting communication operations.</li>
<li>Completion Checking: Checking the status of posted operations.</li>
<li>Progress: Ensuring that pending communication can be moved forward.</li>
</ul>
<p>All LCI APIs are defined in <code><a class="el" href="../../d3/d33/lci_8hpp.html">lci.hpp</a></code> and wrapped in the <code>lci</code> namespace.</p>
<h3><a class="anchor" id="autotoc_md59"></a>
Objectified Flexible Functions (OFF)</h3>
<p>All LCI functions have a _x variant that implements the Objectified Flexible Functions (OFF) idiom. OFF allows optional arguments to be specified in any order, similar to named arguments in Python.</p>
<div class="fragment"><div class="line"># the default post_send function</div>
<div class="line">auto ret = post_send(rank, buf, size, tag, comp);</div>
<div class="line"># the OFF variants</div>
<div class="line">auto ret = post_send_x(rank, buf, size, tag, comp).device(device)();</div>
<div class="line">auto ret = post_send_x(rank, buf, size, tag, comp).matching_policy(matching_policy_t::rank_only).device(device)();</div>
</div><!-- fragment --><p> Internally, an OFF is implemented as a functor with a constructor for positional arguments and setter methods for optional ones. The () operator triggers the actual function call.</p>
<h3><a class="anchor" id="autotoc_md60"></a>
Resource Management</h3>
<p>As a beginner user, you may not need to worry about this part. The only functions you need to know are </p><div class="fragment"><div class="line"><span class="comment">// Initialize the default LCI runtime.</span></div>
<div class="line"><span class="comment">// Similar to MPI_Init.</span></div>
<div class="line"><a class="code hl_function" href="../../d5/dd3/namespacelci.html#aee337a8c81cb3397461d8cd00a2d8f71">lci::g_runtime_init</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Query the rank and total number of ranks.</span></div>
<div class="line"><span class="comment">// Similar to MPI_Comm_rank(MPI_COMM_WORLD) and MPI_Comm_size(MPI_COMM_WORLD).</span></div>
<div class="line"><span class="keywordtype">int</span> rank_me = lci::g_rank_me();</div>
<div class="line"><span class="keywordtype">int</span> rank_n = lci::g_rank_n();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Finalize the default LCI runtime.</span></div>
<div class="line"><span class="comment">// Similar to MPI_Finalize.</span></div>
<div class="line"><a class="code hl_function" href="../../d5/dd3/namespacelci.html#a701a29185fc4b076f1b8a198806fc615">lci::g_runtime_fina</a>();</div>
<div class="ttc" id="anamespacelci_html_a701a29185fc4b076f1b8a198806fc615"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a701a29185fc4b076f1b8a198806fc615">lci::g_runtime_fina</a></div><div class="ttdeci">void g_runtime_fina()</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:239</div></div>
<div class="ttc" id="anamespacelci_html_aee337a8c81cb3397461d8cd00a2d8f71"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#aee337a8c81cb3397461d8cd00a2d8f71">lci::g_runtime_init</a></div><div class="ttdeci">void g_runtime_init()</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:207</div></div>
</div><!-- fragment --><p>For advanced users, you may want to know the following functions/resources (not a complete list): </p>
<h5><a class="anchor" id="autotoc_md61"></a>
Runtime</h5>
<p>Instead of using the global default runtime, you can create your own runtime. This is useful if you are writing a library that might be used in an application that already uses LCI. </p><div class="fragment"><div class="line"><span class="comment">// Create a new LCI runtime.</span></div>
<div class="line"><a class="code hl_class" href="../../dc/d5c/classlci_1_1runtime__t.html">lci::runtime_t</a> runtime = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#acf3dac18c0d46ef14735d3e046bb8134">lci::alloc_runtime</a>();</div>
<div class="line"><span class="comment">// Free the LCI runtime.</span></div>
<div class="line"><a class="code hl_function" href="../../d5/dd3/namespacelci.html#a925ad203c126d3128e7e93d661a1a72b">lci::free_runtime</a>(&amp;runtime);</div>
<div class="line"><span class="comment">// Example: post a receive operation to a specific runtime.</span></div>
<div class="line"><a class="code hl_class" href="../../d7/df5/classlci_1_1post__recv__x.html">lci::post_recv_x</a>(rank, buf, size, tag, comp).<a class="code hl_function" href="../../d7/df5/classlci_1_1post__recv__x.html#a377ff95b56068a680c9f92db75bd9f5d">runtime</a>(runtime)();</div>
<div class="ttc" id="aclasslci_1_1post__recv__x_html"><div class="ttname"><a href="../../d7/df5/classlci_1_1post__recv__x.html">lci::post_recv_x</a></div><div class="ttdoc">The actual implementation for post_recv.</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2000</div></div>
<div class="ttc" id="aclasslci_1_1post__recv__x_html_a377ff95b56068a680c9f92db75bd9f5d"><div class="ttname"><a href="../../d7/df5/classlci_1_1post__recv__x.html#a377ff95b56068a680c9f92db75bd9f5d">lci::post_recv_x::runtime</a></div><div class="ttdeci">post_recv_x &amp;&amp; runtime(runtime_t runtime_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2029</div></div>
<div class="ttc" id="aclasslci_1_1runtime__t_html"><div class="ttname"><a href="../../dc/d5c/classlci_1_1runtime__t.html">lci::runtime_t</a></div><div class="ttdoc">The actual implementation for RESOURCE runtime.</div><div class="ttdef"><b>Definition</b> lci_binding_pre.hpp:135</div></div>
<div class="ttc" id="anamespacelci_html_a925ad203c126d3128e7e93d661a1a72b"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a925ad203c126d3128e7e93d661a1a72b">lci::free_runtime</a></div><div class="ttdeci">void free_runtime(runtime_t *runtime_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:158</div></div>
<div class="ttc" id="anamespacelci_html_acf3dac18c0d46ef14735d3e046bb8134"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#acf3dac18c0d46ef14735d3e046bb8134">lci::alloc_runtime</a></div><div class="ttdeci">runtime_t alloc_runtime()</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:124</div></div>
</div><!-- fragment --><p> All LCI OFFs can take a runtime as an optional argument. If not specified, the default runtime will be used.</p>
<h5><a class="anchor" id="autotoc_md62"></a>
Device</h5>
<p>A device represents a set of communication resources. Using separate devices per thread ensures thread isolation: </p><div class="fragment"><div class="line"><span class="comment">// Create a new LCI device.</span></div>
<div class="line"><a class="code hl_class" href="../../d6/d66/classlci_1_1device__t.html">lci::device_t</a> device = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a1b2bde330a483b62792ab033887af4ab">lci::alloc_device</a>();</div>
<div class="line"><span class="comment">// Free the LCI device.</span></div>
<div class="line"><a class="code hl_function" href="../../d5/dd3/namespacelci.html#a81de742f5f381d60736552db6ed6572a">lci::free_device</a>(&amp;device);</div>
<div class="line"><span class="comment">// Example: post a receive operation to a specific device.</span></div>
<div class="line"><a class="code hl_class" href="../../d7/df5/classlci_1_1post__recv__x.html">lci::post_recv_x</a>(rank, buf, size, tag, comp).<a class="code hl_function" href="../../d7/df5/classlci_1_1post__recv__x.html#a915e9ab9980e2703666515e412f9a921">device</a>(device)();</div>
<div class="ttc" id="aclasslci_1_1device__t_html"><div class="ttname"><a href="../../d6/d66/classlci_1_1device__t.html">lci::device_t</a></div><div class="ttdoc">The actual implementation for RESOURCE device.</div><div class="ttdef"><b>Definition</b> lci_binding_pre.hpp:385</div></div>
<div class="ttc" id="aclasslci_1_1post__recv__x_html_a915e9ab9980e2703666515e412f9a921"><div class="ttname"><a href="../../d7/df5/classlci_1_1post__recv__x.html#a915e9ab9980e2703666515e412f9a921">lci::post_recv_x::device</a></div><div class="ttdeci">post_recv_x &amp;&amp; device(device_t device_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2031</div></div>
<div class="ttc" id="anamespacelci_html_a1b2bde330a483b62792ab033887af4ab"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a1b2bde330a483b62792ab033887af4ab">lci::alloc_device</a></div><div class="ttdeci">device_t alloc_device()</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2821</div></div>
<div class="ttc" id="anamespacelci_html_a81de742f5f381d60736552db6ed6572a"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a81de742f5f381d60736552db6ed6572a">lci::free_device</a></div><div class="ttdeci">void free_device(device_t *device_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2858</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md63"></a>
Communication Posting</h3>
<p>LCI supports:</p><ul>
<li>Send-receive with tag matching.</li>
<li>Active message.</li>
<li>RMA (Remote Memory Access): put/get/put with notification.</li>
</ul>
<p>For those who are not familiar with the terminology: active message is a mechanism that allows the sender to send a message to the receiver and execute a callback function on the receiver side. The receiver does not need to post a receive. RMA is a mechanism that allows one process to read/write the memory of another process without involving the target process.</p>
<p>Below shows the default function signatures of these operations: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="../../d5/dd3/namespacelci.html">lci</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="../../d9/d1e/structlci_1_1status__t.html">status_t</a> <a class="code hl_function" href="../../d5/dd3/namespacelci.html#aab993ec34b1f811cdbeaf425c85ea5e7">post_send</a>(<span class="keywordtype">int</span> rank, <span class="keywordtype">void</span>* local_buffer, <span class="keywordtype">size_t</span> size, <a class="code hl_typedef" href="../../d8/d33/group__LCI__BASIC.html#gaed3bf62f9de2087c7e7b0bcbe89ef151">tag_t</a> tag, <a class="code hl_class" href="../../d1/da7/classlci_1_1comp__t.html">comp_t</a> local_comp);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="../../d9/d1e/structlci_1_1status__t.html">status_t</a> <a class="code hl_function" href="../../d5/dd3/namespacelci.html#af1956c62d0f6291162988088abe93e73">post_recv</a>(<span class="keywordtype">int</span> rank, <span class="keywordtype">void</span>* local_buffer, <span class="keywordtype">size_t</span> size, <a class="code hl_typedef" href="../../d8/d33/group__LCI__BASIC.html#gaed3bf62f9de2087c7e7b0bcbe89ef151">tag_t</a> tag, <a class="code hl_class" href="../../d1/da7/classlci_1_1comp__t.html">comp_t</a> local_comp);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="../../d9/d1e/structlci_1_1status__t.html">status_t</a> <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a317a3e10ecb15866dc346abb2fbe4061">post_am</a>(<span class="keywordtype">int</span> rank, <span class="keywordtype">void</span>* local_buffer, <span class="keywordtype">size_t</span> size, <a class="code hl_class" href="../../d1/da7/classlci_1_1comp__t.html">comp_t</a> local_comp, <a class="code hl_typedef" href="../../d8/d33/group__LCI__BASIC.html#gacd46beb25126ebb7bf83b33e6381d6d2">rcomp_t</a> remote_comp);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="../../d9/d1e/structlci_1_1status__t.html">status_t</a> <a class="code hl_function" href="../../d5/dd3/namespacelci.html#abc413a195b5d0e8e352c98be089576d3">post_put</a>(<span class="keywordtype">int</span> rank, <span class="keywordtype">void</span>* local_buffer, <span class="keywordtype">size_t</span> size, <a class="code hl_class" href="../../d1/da7/classlci_1_1comp__t.html">comp_t</a> local_comp, uintptr_t remote_disp, <a class="code hl_struct" href="../../da/d8d/structlci_1_1rmr__t.html">rmr_t</a> rmr);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="../../d9/d1e/structlci_1_1status__t.html">status_t</a> <a class="code hl_function" href="../../d5/dd3/namespacelci.html#afd5f8b23c99abd4dc49a8e47a058e0ca">post_get</a>(<span class="keywordtype">int</span> rank, <span class="keywordtype">void</span>* local_buffer, <span class="keywordtype">size_t</span> size, <a class="code hl_class" href="../../d1/da7/classlci_1_1comp__t.html">comp_t</a> local_comp, uintptr_t remote_disp, <a class="code hl_struct" href="../../da/d8d/structlci_1_1rmr__t.html">rmr_t</a> rmr);</div>
<div class="ttc" id="aclasslci_1_1comp__t_html"><div class="ttname"><a href="../../d1/da7/classlci_1_1comp__t.html">lci::comp_t</a></div><div class="ttdoc">The actual implementation for RESOURCE comp.</div><div class="ttdef"><b>Definition</b> lci_binding_pre.hpp:269</div></div>
<div class="ttc" id="agroup__LCI__BASIC_html_gacd46beb25126ebb7bf83b33e6381d6d2"><div class="ttname"><a href="../../d8/d33/group__LCI__BASIC.html#gacd46beb25126ebb7bf83b33e6381d6d2">lci::rcomp_t</a></div><div class="ttdeci">uint32_t rcomp_t</div><div class="ttdoc">The type of remote completion handler.</div><div class="ttdef"><b>Definition</b> lci.hpp:364</div></div>
<div class="ttc" id="agroup__LCI__BASIC_html_gaed3bf62f9de2087c7e7b0bcbe89ef151"><div class="ttname"><a href="../../d8/d33/group__LCI__BASIC.html#gaed3bf62f9de2087c7e7b0bcbe89ef151">lci::tag_t</a></div><div class="ttdeci">uint64_t tag_t</div><div class="ttdoc">The type of tag.</div><div class="ttdef"><b>Definition</b> lci.hpp:347</div></div>
<div class="ttc" id="anamespacelci_html"><div class="ttname"><a href="../../d5/dd3/namespacelci.html">lci</a></div><div class="ttdoc">All LCI API functions and classes are defined in this namespace.</div></div>
<div class="ttc" id="anamespacelci_html_a317a3e10ecb15866dc346abb2fbe4061"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a317a3e10ecb15866dc346abb2fbe4061">lci::post_am</a></div><div class="ttdeci">status_t post_am(int rank_in, void *local_buffer_in, size_t size_in, comp_t local_comp_in, rcomp_t remote_comp_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1885</div></div>
<div class="ttc" id="anamespacelci_html_aab993ec34b1f811cdbeaf425c85ea5e7"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#aab993ec34b1f811cdbeaf425c85ea5e7">lci::post_send</a></div><div class="ttdeci">status_t post_send(int rank_in, void *local_buffer_in, size_t size_in, tag_t tag_in, comp_t local_comp_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1967</div></div>
<div class="ttc" id="anamespacelci_html_abc413a195b5d0e8e352c98be089576d3"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#abc413a195b5d0e8e352c98be089576d3">lci::post_put</a></div><div class="ttdeci">status_t post_put(int rank_in, void *local_buffer_in, size_t size_in, comp_t local_comp_in, uintptr_t remote_disp_in, rmr_t rmr_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2131</div></div>
<div class="ttc" id="anamespacelci_html_af1956c62d0f6291162988088abe93e73"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#af1956c62d0f6291162988088abe93e73">lci::post_recv</a></div><div class="ttdeci">status_t post_recv(int rank_in, void *local_buffer_in, size_t size_in, tag_t tag_in, comp_t local_comp_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2046</div></div>
<div class="ttc" id="anamespacelci_html_afd5f8b23c99abd4dc49a8e47a058e0ca"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#afd5f8b23c99abd4dc49a8e47a058e0ca">lci::post_get</a></div><div class="ttdeci">status_t post_get(int rank_in, void *local_buffer_in, size_t size_in, comp_t local_comp_in, uintptr_t remote_disp_in, rmr_t rmr_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2213</div></div>
<div class="ttc" id="astructlci_1_1rmr__t_html"><div class="ttname"><a href="../../da/d8d/structlci_1_1rmr__t.html">lci::rmr_t</a></div><div class="ttdoc">The type of remote memory region.</div><div class="ttdef"><b>Definition</b> lci.hpp:330</div></div>
<div class="ttc" id="astructlci_1_1status__t_html"><div class="ttname"><a href="../../d9/d1e/structlci_1_1status__t.html">lci::status_t</a></div><div class="ttdoc">The type of the completion desciptor for a posted communication.</div><div class="ttdef"><b>Definition</b> lci.hpp:443</div></div>
</div><!-- fragment --><p>Where is write with notification? <code>post_put</code> can take an optional <code>rcomp</code> argument to specify a remote completion handle.</p>
<p>All functions here are non-blocking: they merely <em>post</em> the communication operation and return immediately. The actual communication may not be completed yet. A communication posting function returns a <code>status_t</code> object that can be in one of the three states:</p><ul>
<li><b>done</b>: the operation is completed.</li>
<li><b>posted</b>: the operation is posted but not completed yet.</li>
<li><b>retry</b>: the operation cannot be posted due to a non-fatal error (typically, some resources are temporarily unavailable). You can retry the posting.</li>
</ul>
<p>You can use the <code>is_done/is_posted/is_retry</code> methods to check the status of the operation.</p>
<p>Below is an example of how to post a send operation and blocking wait for it to complete: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="../../d5/dd3/namespacelci.html#aab993ec34b1f811cdbeaf425c85ea5e7">post_send</a>(<span class="keywordtype">int</span> rank, <span class="keywordtype">void</span>* buf, <span class="keywordtype">size_t</span> size, <a class="code hl_typedef" href="../../d8/d33/group__LCI__BASIC.html#gaed3bf62f9de2087c7e7b0bcbe89ef151">tag_t</a> tag) {</div>
<div class="line">  <a class="code hl_class" href="../../d1/da7/classlci_1_1comp__t.html">comp_t</a> <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">sync</a> = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#af302b7808e35efca489ce25644ab249e">alloc_sync</a>();</div>
<div class="line">  <a class="code hl_struct" href="../../d9/d1e/structlci_1_1status__t.html">status_t</a> status;</div>
<div class="line">  <span class="keywordflow">do</span> {</div>
<div class="line">    status = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#aab993ec34b1f811cdbeaf425c85ea5e7">post_send</a>(rank, buf, size, tag, <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">sync</a>);</div>
<div class="line">    <a class="code hl_function" href="../../d5/dd3/namespacelci.html#ad55bf2fa3c43f989f8f382fa8c41a387">progress</a>();</div>
<div class="line">  } <span class="keywordflow">while</span> (status.<a class="code hl_function" href="../../d9/d1e/structlci_1_1status__t.html#abaa9d395f7105a81a24bf3ec6b670643">is_retry</a>());</div>
<div class="line">  <span class="keywordflow">if</span> (status.<a class="code hl_function" href="../../d9/d1e/structlci_1_1status__t.html#a9b8fe320747cab88b12b2eb6bdc2f970">is_posted</a>()) {</div>
<div class="line">    <span class="keywordflow">while</span> (<a class="code hl_function" href="../../d5/dd3/namespacelci.html#ad05235498477d26522d212f4ea5000cb">sync_test</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">sync</a>, &amp;status) == <span class="keyword">false</span>)</div>
<div class="line">      <a class="code hl_function" href="../../d5/dd3/namespacelci.html#ad55bf2fa3c43f989f8f382fa8c41a387">progress</a>();</div>
<div class="line">  }</div>
<div class="line">  assert(status.<a class="code hl_function" href="../../d9/d1e/structlci_1_1status__t.html#a7d4d6335a16e1060b2cf8a03c767a3b7">is_done</a>());</div>
<div class="line">  <span class="comment">// At this point, the send operation is completed</span></div>
<div class="line">  <span class="comment">// and the status object contains the information about the completed operation.</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacelci_html_a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">lci::attr_comp_type_t::sync</a></div><div class="ttdeci">@ sync</div><div class="ttdef"><b>Definition</b> lci_binding_pre.hpp:34</div></div>
<div class="ttc" id="anamespacelci_html_ad05235498477d26522d212f4ea5000cb"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#ad05235498477d26522d212f4ea5000cb">lci::sync_test</a></div><div class="ttdeci">bool sync_test(comp_t comp_in, status_t *p_out_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1183</div></div>
<div class="ttc" id="anamespacelci_html_ad55bf2fa3c43f989f8f382fa8c41a387"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#ad55bf2fa3c43f989f8f382fa8c41a387">lci::progress</a></div><div class="ttdeci">error_t progress()</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2253</div></div>
<div class="ttc" id="anamespacelci_html_af302b7808e35efca489ce25644ab249e"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#af302b7808e35efca489ce25644ab249e">lci::alloc_sync</a></div><div class="ttdeci">comp_t alloc_sync()</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1143</div></div>
<div class="ttc" id="astructlci_1_1status__t_html_a7d4d6335a16e1060b2cf8a03c767a3b7"><div class="ttname"><a href="../../d9/d1e/structlci_1_1status__t.html#a7d4d6335a16e1060b2cf8a03c767a3b7">lci::status_t::is_done</a></div><div class="ttdeci">bool is_done() const</div><div class="ttdef"><b>Definition</b> lci.hpp:459</div></div>
<div class="ttc" id="astructlci_1_1status__t_html_a9b8fe320747cab88b12b2eb6bdc2f970"><div class="ttname"><a href="../../d9/d1e/structlci_1_1status__t.html#a9b8fe320747cab88b12b2eb6bdc2f970">lci::status_t::is_posted</a></div><div class="ttdeci">bool is_posted() const</div><div class="ttdef"><b>Definition</b> lci.hpp:460</div></div>
<div class="ttc" id="astructlci_1_1status__t_html_abaa9d395f7105a81a24bf3ec6b670643"><div class="ttname"><a href="../../d9/d1e/structlci_1_1status__t.html#abaa9d395f7105a81a24bf3ec6b670643">lci::status_t::is_retry</a></div><div class="ttdeci">bool is_retry() const</div><div class="ttdef"><b>Definition</b> lci.hpp:461</div></div>
</div><!-- fragment --><p> The usage of synchronizer (<code>sync</code>) and <code>progress</code> will be explained in the next section.</p>
<h3><a class="anchor" id="autotoc_md64"></a>
Completion Checking</h3>
<p>LCI offers several mechanisms to detect when a posted operation completes. These mechanisms are designed to support both synchronous and asynchronous programming styles.</p>
<h4><a class="anchor" id="autotoc_md65"></a>
Synchronizer</h4>
<p>A synchronizer behaves similarly to an MPI request. You can wait for its completion using <code>sync_wait</code> or test it with <code>sync_test</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="../../d1/da7/classlci_1_1comp__t.html">comp_t</a> <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">sync</a> = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#af302b7808e35efca489ce25644ab249e">alloc_sync</a>();</div>
<div class="line"><a class="code hl_struct" href="../../d9/d1e/structlci_1_1status__t.html">status_t</a> status = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#aab993ec34b1f811cdbeaf425c85ea5e7">post_send</a>(rank, buf, size, tag, <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">sync</a>);</div>
<div class="line"><span class="keywordflow">if</span> (status.<a class="code hl_function" href="../../d9/d1e/structlci_1_1status__t.html#a9b8fe320747cab88b12b2eb6bdc2f970">is_posted</a>()) {</div>
<div class="line">  <span class="keywordflow">while</span> (<a class="code hl_function" href="../../d5/dd3/namespacelci.html#ad05235498477d26522d212f4ea5000cb">sync_test</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">sync</a>, <span class="keyword">nullptr</span>) == <span class="keyword">false</span>) {</div>
<div class="line">    <a class="code hl_function" href="../../d5/dd3/namespacelci.html#ad55bf2fa3c43f989f8f382fa8c41a387">progress</a>();  <span class="comment">// call progress to ensure the operation can be completed</span></div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Alternatively, you can use sync_wait</span></div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="../../d5/dd3/namespacelci.html#a820947e1c3c281fa0510e66d5532a43c">free_comp</a>(&amp;<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">sync</a>);</div>
<div class="ttc" id="anamespacelci_html_a820947e1c3c281fa0510e66d5532a43c"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a820947e1c3c281fa0510e66d5532a43c">lci::free_comp</a></div><div class="ttdeci">void free_comp(comp_t *comp_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:946</div></div>
</div><!-- fragment --><p>Optionally, a synchronizer can accept multiple completion signals before becoming ready. For example,</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="../../d1/da7/classlci_1_1comp__t.html">comp_t</a> <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">sync</a> = <a class="code hl_class" href="../../dd/da4/classlci_1_1alloc__sync__x.html">alloc_sync_x</a>().<a class="code hl_function" href="../../dd/da4/classlci_1_1alloc__sync__x.html#a778a0249d3afc6949b987d0caf3fcc78">threshold</a>(2)();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (...) {</div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#aab993ec34b1f811cdbeaf425c85ea5e7">post_send</a>(..., <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">sync</a>);</div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#af1956c62d0f6291162988088abe93e73">post_recv</a>(..., <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">sync</a>);</div>
<div class="line"> </div>
<div class="line">  status = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a420877a3c976eb6a6dd692616e18899d">sync_wait</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">sync</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="../../d5/dd3/namespacelci.html#a820947e1c3c281fa0510e66d5532a43c">free_comp</a>(&amp;<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">sync</a>);</div>
<div class="ttc" id="aclasslci_1_1alloc__sync__x_html"><div class="ttname"><a href="../../dd/da4/classlci_1_1alloc__sync__x.html">lci::alloc_sync_x</a></div><div class="ttdoc">The actual implementation for alloc_sync.</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1121</div></div>
<div class="ttc" id="aclasslci_1_1alloc__sync__x_html_a778a0249d3afc6949b987d0caf3fcc78"><div class="ttname"><a href="../../dd/da4/classlci_1_1alloc__sync__x.html#a778a0249d3afc6949b987d0caf3fcc78">lci::alloc_sync_x::threshold</a></div><div class="ttdeci">alloc_sync_x &amp;&amp; threshold(int threshold_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1134</div></div>
<div class="ttc" id="anamespacelci_html_a420877a3c976eb6a6dd692616e18899d"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a420877a3c976eb6a6dd692616e18899d">lci::sync_wait</a></div><div class="ttdeci">void sync_wait(comp_t comp_in, status_t *p_out_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1229</div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md66"></a>
Completion Queue</h4>
<p>Applications that expect a large number of asynchronous operations can use a completion queue. Completed operations are pushed into the queue and can be polled later:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="../../d1/da7/classlci_1_1comp__t.html">comp_t</a> <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba1c29ac0ab69660bfc944d1a913ecda64">cq</a> = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a6f475a6e5ce001cca691795999bdb46f">alloc_cq</a>();</div>
<div class="line"><span class="comment">// can have many pending operations</span></div>
<div class="line"><a class="code hl_struct" href="../../d9/d1e/structlci_1_1status__t.html">status_t</a> status = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a317a3e10ecb15866dc346abb2fbe4061">post_am</a>(..., <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba1c29ac0ab69660bfc944d1a913ecda64">cq</a>, ...);</div>
<div class="line"><span class="comment">// Later or in another thread:</span></div>
<div class="line"><a class="code hl_struct" href="../../d9/d1e/structlci_1_1status__t.html">status_t</a> status = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a5a9a377509b16d786a6c4fb879b91677">cq_pop</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba1c29ac0ab69660bfc944d1a913ecda64">cq</a>);</div>
<div class="line"><span class="keywordflow">if</span> (status.<a class="code hl_function" href="../../d9/d1e/structlci_1_1status__t.html#a7d4d6335a16e1060b2cf8a03c767a3b7">is_done</a>()) {</div>
<div class="line">  <span class="comment">// Process completed operation</span></div>
<div class="line">  <span class="comment">// status contains information about the completed operation</span></div>
<div class="line">  <span class="comment">// such as the rank, tag, and buffer.</span></div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="../../d5/dd3/namespacelci.html#a820947e1c3c281fa0510e66d5532a43c">free_comp</a>(&amp;<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba1c29ac0ab69660bfc944d1a913ecda64">cq</a>);</div>
<div class="ttc" id="anamespacelci_html_a5a9a377509b16d786a6c4fb879b91677"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a5a9a377509b16d786a6c4fb879b91677">lci::cq_pop</a></div><div class="ttdeci">status_t cq_pop(comp_t comp_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1423</div></div>
<div class="ttc" id="anamespacelci_html_a610912d197faa01c2f04666209b814bba1c29ac0ab69660bfc944d1a913ecda64"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba1c29ac0ab69660bfc944d1a913ecda64">lci::attr_comp_type_t::cq</a></div><div class="ttdeci">@ cq</div><div class="ttdef"><b>Definition</b> lci_binding_pre.hpp:36</div></div>
<div class="ttc" id="anamespacelci_html_a6f475a6e5ce001cca691795999bdb46f"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a6f475a6e5ce001cca691795999bdb46f">lci::alloc_cq</a></div><div class="ttdeci">comp_t alloc_cq()</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1386</div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md67"></a>
Handler</h4>
<p>You can also register a callback handler. This is useful for advanced users who want LCI to directly invoke a function upon completion.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_handler(<a class="code hl_struct" href="../../d9/d1e/structlci_1_1status__t.html">status_t</a> status) {</div>
<div class="line">  std::free(status.buf); <span class="comment">// free the message buffer</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="../../d1/da7/classlci_1_1comp__t.html">comp_t</a> <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbac1cbfe271a40788a00e8bf8574d94d4b">handler</a> = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a9a4b7e4a4222bd6d51f71150a927ac28">alloc_handler</a>(my_handler);</div>
<div class="line"><a class="code hl_struct" href="../../d9/d1e/structlci_1_1status__t.html">status_t</a> status = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#aab993ec34b1f811cdbeaf425c85ea5e7">post_send</a>(rank, buf, size, tag, <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbac1cbfe271a40788a00e8bf8574d94d4b">handler</a>);</div>
<div class="ttc" id="anamespacelci_html_a610912d197faa01c2f04666209b814bbac1cbfe271a40788a00e8bf8574d94d4b"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbac1cbfe271a40788a00e8bf8574d94d4b">lci::attr_comp_type_t::handler</a></div><div class="ttdeci">@ handler</div><div class="ttdef"><b>Definition</b> lci_binding_pre.hpp:37</div></div>
<div class="ttc" id="anamespacelci_html_a9a4b7e4a4222bd6d51f71150a927ac28"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a9a4b7e4a4222bd6d51f71150a927ac28">lci::alloc_handler</a></div><div class="ttdeci">comp_t alloc_handler(comp_handler_t handler_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1466</div></div>
</div><!-- fragment --><p>The handler is automatically called once the operation completes locally.</p>
<h4><a class="anchor" id="autotoc_md68"></a>
Graph (Advanced)</h4>
<p>For complex asynchronous flows, LCI also supports <code>graph_t</code>, a completion object that represents a Directed Acyclic Graph (DAG) of operations and callbacks. This is similar in spirit to CUDA Graphs and can be used to build efficient non-blocking collectives.</p>
<p>(Check the "Non-blocking Barrier" example for more details.)</p>
<h3><a class="anchor" id="autotoc_md69"></a>
Progress</h3>
<p>LCI decouples communication progress from posting and completion operations. Unlike MPI, where progress is implicit, LCI uses an explicit <code>progress()</code> call.</p>
<p>This enables users to:</p>
<ul>
<li>Call <code>progress()</code> periodically in application threads</li>
<li>Dedicate threads to call <code>progress()</code> continuously</li>
<li>Integrate progress into event loops</li>
</ul>
<h5><a class="anchor" id="autotoc_md70"></a>
Basic Usage</h5>
<div class="fragment"><div class="line"><span class="comment">// On default device</span></div>
<div class="line"><a class="code hl_function" href="../../d5/dd3/namespacelci.html#ad55bf2fa3c43f989f8f382fa8c41a387">lci::progress</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// With specified device</span></div>
<div class="line"><a class="code hl_class" href="../../df/dd2/classlci_1_1progress__x.html">lci::progress_x</a>().<a class="code hl_function" href="../../df/dd2/classlci_1_1progress__x.html#a48c1029e1e0f41f220ae43586fba5d1b">device</a>(device)();</div>
<div class="ttc" id="aclasslci_1_1progress__x_html"><div class="ttname"><a href="../../df/dd2/classlci_1_1progress__x.html">lci::progress_x</a></div><div class="ttdoc">The actual implementation for progress.</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2233</div></div>
<div class="ttc" id="aclasslci_1_1progress__x_html_a48c1029e1e0f41f220ae43586fba5d1b"><div class="ttname"><a href="../../df/dd2/classlci_1_1progress__x.html#a48c1029e1e0f41f220ae43586fba5d1b">lci::progress_x::device</a></div><div class="ttdeci">progress_x &amp;&amp; device(device_t device_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2245</div></div>
</div><!-- fragment --><p>Call <code>progress()</code> frequently to ensure pending operations complete. In multithreaded programs, you can call <code>progress()</code> on a specific device.</p>
<h2><a class="anchor" id="autotoc_md71"></a>
Other Materials</h2>
<p>Check the <code>examples</code> and <code>tests</code> subdirectory for more example code.</p>
<p>Read <a href="https://arxiv.org/abs/2505.01864">this paper</a> to comprehensively understand LCI interface and runtime design.</p>
<p>Check out the API documentation for more details.</p>
<h2><a class="anchor" id="autotoc_md72"></a>
Examples</h2>
<h3><a class="anchor" id="autotoc_md73"></a>
Hello World</h3>
<p>This example shows the LCI runtime lifecycle and the query of rank.</p>
<details >
<summary >
Click to expand code</summary>
<div class="fragment"><div class="line"><span class="comment">// Copyright (c) 2025 The LCI Project Authors</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: NCSA</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unistd.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d3/d33/lci_8hpp.html">lci.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// This example shows the LCI runtime lifecycle and the query of rank.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** args)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">char</span> hostname[64];</div>
<div class="line">  gethostname(hostname, 64);</div>
<div class="line">  <span class="comment">// Initialize the global default runtime.</span></div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#aee337a8c81cb3397461d8cd00a2d8f71">lci::g_runtime_init</a>();</div>
<div class="line">  <span class="comment">// After at least one runtime is active, we can query the rank and nranks.</span></div>
<div class="line">  <span class="comment">// rank is the id of the current process</span></div>
<div class="line">  <span class="comment">// nranks is the total number of the processes in the current job.</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Hello world from rank &quot;</span> &lt;&lt; <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a9852426eb34e7849f5b6e1db60e49500">lci::get_rank_me</a>() &lt;&lt; <span class="stringliteral">&quot; of &quot;</span></div>
<div class="line">            &lt;&lt; <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a6e99f95e9b71b259ea5078c23d0ff4b9">lci::get_rank_n</a>() &lt;&lt; <span class="stringliteral">&quot; on &quot;</span> &lt;&lt; hostname &lt;&lt; std::endl;</div>
<div class="line">  <span class="comment">// Finalize the global default runtime</span></div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a701a29185fc4b076f1b8a198806fc615">lci::g_runtime_fina</a>();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="alci_8hpp_html"><div class="ttname"><a href="../../d3/d33/lci_8hpp.html">lci.hpp</a></div></div>
<div class="ttc" id="anamespacelci_html_a6e99f95e9b71b259ea5078c23d0ff4b9"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a6e99f95e9b71b259ea5078c23d0ff4b9">lci::get_rank_n</a></div><div class="ttdeci">int get_rank_n()</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:72</div></div>
<div class="ttc" id="anamespacelci_html_a9852426eb34e7849f5b6e1db60e49500"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a9852426eb34e7849f5b6e1db60e49500">lci::get_rank_me</a></div><div class="ttdeci">int get_rank_me()</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:40</div></div>
</div><!-- fragment --> </details>
<details >
<summary >
Click to expand example output</summary>
<div class="fragment"><div class="line">$ lcrun -n 4 ./lci_hello_world </div>
<div class="line">Hello world from rank 1 of 4 on &lt;hostname&gt;</div>
<div class="line">Hello world from rank 3 of 4 on &lt;hostname&gt;</div>
<div class="line">Hello world from rank 0 of 4 on &lt;hostname&gt;</div>
<div class="line">Hello world from rank 2 of 4 on &lt;hostname&gt;</div>
</div><!-- fragment --> </details>
<h3><a class="anchor" id="autotoc_md74"></a>
Hello World (Active Message)</h3>
<p>This example shows the usages of basic communication operations (active message) and completion mechanisms (synchronizer and handler).</p>
<details >
<summary >
Click to expand code</summary>
<div class="fragment"><div class="line"><span class="comment">// Copyright (c) 2025 The LCI Project Authors</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: NCSA</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d3/d33/lci_8hpp.html">lci.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// This example shows the usages of basic communication operations (active</span></div>
<div class="line"><span class="comment">// message) and completion mechanisms (synchronizer and handler).</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Using a flag for simple termination detection.</span></div>
<div class="line"><span class="keywordtype">bool</span> received = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define the function to be triggered when the active message arrives.</span></div>
<div class="line"><span class="keywordtype">void</span> am_handler(<a class="code hl_struct" href="../../d9/d1e/structlci_1_1status__t.html">lci::status_t</a> status)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Get the active message payload.</span></div>
<div class="line">  std::string payload_str(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(status.<a class="code hl_variable" href="../../d9/d1e/structlci_1_1status__t.html#a831eecf0a79ddc81724fc813148bcfd3">buffer</a>), status.<a class="code hl_variable" href="../../d9/d1e/structlci_1_1status__t.html#a723483ab2c1145824fc16a44a44b1997">size</a>);</div>
<div class="line">  <span class="comment">// Active message payload buffer is allocated by the LCI runtime using</span></div>
<div class="line">  <span class="comment">// `malloc` by default. The user are responsible for freeing it after use.</span></div>
<div class="line">  free(status.<a class="code hl_variable" href="../../d9/d1e/structlci_1_1status__t.html#a831eecf0a79ddc81724fc813148bcfd3">buffer</a>);</div>
<div class="line">  <span class="comment">// Print the hello world message.</span></div>
<div class="line">  std::ostringstream oss;</div>
<div class="line">  oss &lt;&lt; <span class="stringliteral">&quot;Rank &quot;</span> &lt;&lt; <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a9852426eb34e7849f5b6e1db60e49500">lci::get_rank_me</a>() &lt;&lt; <span class="stringliteral">&quot; received active message from rank &quot;</span></div>
<div class="line">      &lt;&lt; status.<a class="code hl_variable" href="../../d9/d1e/structlci_1_1status__t.html#ad0e6fb6de5142ab266d2b338178e183e">rank</a> &lt;&lt; <span class="stringliteral">&quot;. Payload: &quot;</span> &lt;&lt; payload_str &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; oss.str();</div>
<div class="line">  <span class="comment">// Set the received flag to true.</span></div>
<div class="line">  received = <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** args)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#aee337a8c81cb3397461d8cd00a2d8f71">lci::g_runtime_init</a>();</div>
<div class="line">  <span class="comment">// We use &quot;synchronizer&quot; as the source side completion object.</span></div>
<div class="line">  <span class="comment">// It is similar to a MPI request, but has an optional argument `threshold` to</span></div>
<div class="line">  <span class="comment">// accept multiple signals before becoming ready.</span></div>
<div class="line">  <a class="code hl_class" href="../../d1/da7/classlci_1_1comp__t.html">lci::comp_t</a> <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">sync</a> = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#af302b7808e35efca489ce25644ab249e">lci::alloc_sync</a>();</div>
<div class="line">  <span class="comment">// Register the active message handler as the target side completion object.</span></div>
<div class="line">  <a class="code hl_class" href="../../d1/da7/classlci_1_1comp__t.html">lci::comp_t</a> <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbac1cbfe271a40788a00e8bf8574d94d4b">handler</a> = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a9a4b7e4a4222bd6d51f71150a927ac28">lci::alloc_handler</a>(am_handler);</div>
<div class="line">  <span class="comment">// Since handler/cq needs to be referenced by another process, we need to</span></div>
<div class="line">  <span class="comment">// register it into a remote completion handler.</span></div>
<div class="line">  <span class="comment">// Since all ranks register the rcomp, all ranks will automatically have a</span></div>
<div class="line">  <span class="comment">// symmetric view. We do not need to explicitly exchange them.</span></div>
<div class="line">  <a class="code hl_typedef" href="../../d8/d33/group__LCI__BASIC.html#gacd46beb25126ebb7bf83b33e6381d6d2">lci::rcomp_t</a> rcomp = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a7952c7d36886b256a2c4d9be1f63aa47">lci::register_rcomp</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbac1cbfe271a40788a00e8bf8574d94d4b">handler</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Put a barrier here to ensure all ranks have registered the handler</span></div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#ae6054124daf3cd24d181b63ccbb7ce6c">lci::barrier</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d5/dd3/namespacelci.html#a9852426eb34e7849f5b6e1db60e49500">lci::get_rank_me</a>() == 0) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> target = 0; target &lt; <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a6e99f95e9b71b259ea5078c23d0ff4b9">lci::get_rank_n</a>(); ++target) {</div>
<div class="line">      <span class="comment">// Prepare the active message payload.</span></div>
<div class="line">      std::string payload =</div>
<div class="line">          <span class="stringliteral">&quot;Hello from rank &quot;</span> + std::to_string(<a class="code hl_function" href="../../d5/dd3/namespacelci.html#a9852426eb34e7849f5b6e1db60e49500">lci::get_rank_me</a>());</div>
<div class="line">      <span class="comment">// Post the active message to the target rank.</span></div>
<div class="line">      <span class="keyword">auto</span> send_buf =</div>
<div class="line">          <span class="keyword">const_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(payload.data()));</div>
<div class="line">      <span class="comment">// Unlike MPI_Isend, LCI posting operation can return a status in one of</span></div>
<div class="line">      <span class="comment">// the three states:</span></div>
<div class="line">      <span class="comment">// 1. `retry`: the posting failed due to resource being temporarily busy,</span></div>
<div class="line">      <span class="comment">// and the user can retry.</span></div>
<div class="line">      <a class="code hl_struct" href="../../d9/d1e/structlci_1_1status__t.html">lci::status_t</a> status;</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        status = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a317a3e10ecb15866dc346abb2fbe4061">lci::post_am</a>(target, send_buf, payload.size(), <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">sync</a>, rcomp);</div>
<div class="line">        <a class="code hl_function" href="../../d5/dd3/namespacelci.html#ad55bf2fa3c43f989f8f382fa8c41a387">lci::progress</a>();</div>
<div class="line">      } <span class="keywordflow">while</span> (status.<a class="code hl_function" href="../../d9/d1e/structlci_1_1status__t.html#abaa9d395f7105a81a24bf3ec6b670643">is_retry</a>());</div>
<div class="line">      <span class="comment">// 2. `posted`: the operation is posted, and the completion object will be</span></div>
<div class="line">      <span class="comment">// signaled.</span></div>
<div class="line">      <span class="keywordflow">if</span> (status.<a class="code hl_function" href="../../d9/d1e/structlci_1_1status__t.html#a9b8fe320747cab88b12b2eb6bdc2f970">is_posted</a>()) {</div>
<div class="line">        <span class="keywordflow">while</span> (<a class="code hl_function" href="../../d5/dd3/namespacelci.html#ad05235498477d26522d212f4ea5000cb">lci::sync_test</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">sync</a>, &amp;status <span class="comment">/* can be nullptr */</span>) == <span class="keyword">false</span>) {</div>
<div class="line">          <a class="code hl_function" href="../../d5/dd3/namespacelci.html#ad55bf2fa3c43f989f8f382fa8c41a387">lci::progress</a>();</div>
<div class="line">        }</div>
<div class="line">        assert(status.<a class="code hl_function" href="../../d9/d1e/structlci_1_1status__t.html#a7d4d6335a16e1060b2cf8a03c767a3b7">is_done</a>());</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// 3. `done`: the operation is completed, the completion object will not</span></div>
<div class="line">      <span class="comment">// be signaled, and the user can check the status.</span></div>
<div class="line">      assert(status.<a class="code hl_function" href="../../d9/d1e/structlci_1_1status__t.html#a7d4d6335a16e1060b2cf8a03c767a3b7">is_done</a>());</div>
<div class="line">      <span class="comment">// at this point, all fields in the status object are valid.</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Wait for the active message to arrive.</span></div>
<div class="line">  <span class="keywordflow">while</span> (!received) {</div>
<div class="line">    <a class="code hl_function" href="../../d5/dd3/namespacelci.html#ad55bf2fa3c43f989f8f382fa8c41a387">lci::progress</a>();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Clean up the completion objects.</span></div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a820947e1c3c281fa0510e66d5532a43c">lci::free_comp</a>(&amp;<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbac1cbfe271a40788a00e8bf8574d94d4b">handler</a>);</div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a820947e1c3c281fa0510e66d5532a43c">lci::free_comp</a>(&amp;<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba63ad9d34f3503826e5f649ae6b7ac92c">sync</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a701a29185fc4b076f1b8a198806fc615">lci::g_runtime_fina</a>();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacelci_html_a7952c7d36886b256a2c4d9be1f63aa47"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a7952c7d36886b256a2c4d9be1f63aa47">lci::register_rcomp</a></div><div class="ttdeci">rcomp_t register_rcomp(comp_t comp_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1063</div></div>
<div class="ttc" id="anamespacelci_html_ae6054124daf3cd24d181b63ccbb7ce6c"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#ae6054124daf3cd24d181b63ccbb7ce6c">lci::barrier</a></div><div class="ttdeci">void barrier()</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2302</div></div>
<div class="ttc" id="astructlci_1_1status__t_html_a723483ab2c1145824fc16a44a44b1997"><div class="ttname"><a href="../../d9/d1e/structlci_1_1status__t.html#a723483ab2c1145824fc16a44a44b1997">lci::status_t::size</a></div><div class="ttdeci">size_t size</div><div class="ttdef"><b>Definition</b> lci.hpp:447</div></div>
<div class="ttc" id="astructlci_1_1status__t_html_a831eecf0a79ddc81724fc813148bcfd3"><div class="ttname"><a href="../../d9/d1e/structlci_1_1status__t.html#a831eecf0a79ddc81724fc813148bcfd3">lci::status_t::buffer</a></div><div class="ttdeci">void * buffer</div><div class="ttdef"><b>Definition</b> lci.hpp:446</div></div>
<div class="ttc" id="astructlci_1_1status__t_html_ad0e6fb6de5142ab266d2b338178e183e"><div class="ttname"><a href="../../d9/d1e/structlci_1_1status__t.html#ad0e6fb6de5142ab266d2b338178e183e">lci::status_t::rank</a></div><div class="ttdeci">int rank</div><div class="ttdef"><b>Definition</b> lci.hpp:445</div></div>
</div><!-- fragment --> </details>
<details >
<summary >
Click to expand example output</summary>
<div class="fragment"><div class="line">$ lcrun -n 4 ./lci_hello_world_am</div>
<div class="line">Rank 1 received active message from rank 0. Payload: Hello from rank 0</div>
<div class="line">Rank 2 received active message from rank 0. Payload: Hello from rank 0</div>
<div class="line">Rank 3 received active message from rank 0. Payload: Hello from rank 0</div>
<div class="line">Rank 0 received active message from rank 0. Payload: Hello from rank 0</div>
</div><!-- fragment --> </details>
<h3><a class="anchor" id="autotoc_md75"></a>
Distributed Array</h3>
<p>This example shows the usage of RMA (Remote Memory Access) operations to implement a distributed array. </p><details >
<summary >
Click to expand code</summary>
<div class="fragment"><div class="line"><span class="comment">// Copyright (c) 2025 The LCI Project Authors</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: NCSA</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d3/d33/lci_8hpp.html">lci.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// This example shows the usage of the LCI one-sided RMA operations through the</span></div>
<div class="line"><span class="comment">// implementation of a simple distributed array.</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>distributed_array_t</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  distributed_array_t(<span class="keywordtype">size_t</span> size, T default_val) : m_size(size)</div>
<div class="line">  {</div>
<div class="line">    m_per_rank_size = size / <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a6e99f95e9b71b259ea5078c23d0ff4b9">lci::get_rank_n</a>();</div>
<div class="line">    m_local_start = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a9852426eb34e7849f5b6e1db60e49500">lci::get_rank_me</a>() * m_per_rank_size;</div>
<div class="line">    m_data.resize(m_per_rank_size, default_val);</div>
<div class="line">    m_rmrs.resize(<a class="code hl_function" href="../../d5/dd3/namespacelci.html#a6e99f95e9b71b259ea5078c23d0ff4b9">lci::get_rank_n</a>());</div>
<div class="line">    <span class="comment">// RMA operations allow users to directly read/write remote memory on other</span></div>
<div class="line">    <span class="comment">// processes. To enable this, the following steps are required: (1) Each</span></div>
<div class="line">    <span class="comment">// target process (i.e., the process whose memory will be accessed remotely)</span></div>
<div class="line">    <span class="comment">//     must register its local memory region and obtain a corresponding</span></div>
<div class="line">    <span class="comment">//     remote key (rmr).</span></div>
<div class="line">    <span class="comment">// (2) Each target process must then share its base address and rmr with</span></div>
<div class="line">    <span class="comment">// all other ranks.</span></div>
<div class="line">    <span class="comment">//     This is typically done using an allgather or similar collective</span></div>
<div class="line">    <span class="comment">//     operation.</span></div>
<div class="line">    <span class="comment">// These steps ensure that every process has the information needed to</span></div>
<div class="line">    <span class="comment">// perform one-sided RMA operations (e.g., put/get) to any other process&#39;s</span></div>
<div class="line">    <span class="comment">// registered memory buffer.</span></div>
<div class="line">    mr = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#aaf51f7172447f6fb23b5f98f6e124ff9">lci::register_memory</a>(m_data.data(), m_data.size() * <span class="keyword">sizeof</span>(T));</div>
<div class="line">    <span class="comment">// exchange the memory registration information with other ranks</span></div>
<div class="line">    <a class="code hl_struct" href="../../da/d8d/structlci_1_1rmr__t.html">lci::rmr_t</a> rmr = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#ab6480639b459da398972da8c1f854646">lci::get_rmr</a>(mr);</div>
<div class="line">    <a class="code hl_function" href="../../d5/dd3/namespacelci.html#acfab5281c6310f13d1a4c36fb164e89d">lci::allgather</a>(&amp;rmr, m_rmrs.data(), <span class="keyword">sizeof</span>(<a class="code hl_struct" href="../../da/d8d/structlci_1_1rmr__t.html">lci::rmr_t</a>));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  ~distributed_array_t()</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// deregister my memory buffer</span></div>
<div class="line">    <span class="comment">// we need a barrier to ensure that all remote operations are completed</span></div>
<div class="line">    <a class="code hl_function" href="../../d5/dd3/namespacelci.html#ae6054124daf3cd24d181b63ccbb7ce6c">lci::barrier</a>();</div>
<div class="line">    <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a24873f5ddc295cfc7f7a6109c0687788">lci::deregister_memory</a>(&amp;mr);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// a blocking get operation</span></div>
<div class="line">  T get(<span class="keywordtype">size_t</span> index)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">int</span> target_rank = get_target_rank(index);</div>
<div class="line">    <span class="keywordtype">size_t</span> local_index = get_local_index(index);</div>
<div class="line">    lci::status_t status;</div>
<div class="line">    T value;</div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">      status =</div>
<div class="line">          <a class="code hl_function" href="../../d5/dd3/namespacelci.html#afd5f8b23c99abd4dc49a8e47a058e0ca">lci::post_get</a>(target_rank, &amp;value, <span class="keyword">sizeof</span>(T), <a class="code hl_variable" href="../../d8/d33/group__LCI__BASIC.html#gafe52227fda9cf2b4026a3fd7925c2016">lci::COMP_NULL_RETRY</a>,</div>
<div class="line">                        local_index * <span class="keyword">sizeof</span>(T), m_rmrs[target_rank]);</div>
<div class="line">      <a class="code hl_function" href="../../d5/dd3/namespacelci.html#ad55bf2fa3c43f989f8f382fa8c41a387">lci::progress</a>();</div>
<div class="line">    } <span class="keywordflow">while</span> (status.<a class="code hl_function" href="../../d9/d1e/structlci_1_1status__t.html#abaa9d395f7105a81a24bf3ec6b670643">is_retry</a>());</div>
<div class="line">    assert(status.<a class="code hl_function" href="../../d9/d1e/structlci_1_1status__t.html#a7d4d6335a16e1060b2cf8a03c767a3b7">is_done</a>());</div>
<div class="line">    <span class="keywordflow">return</span> value;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// a blocking put operation</span></div>
<div class="line">  <span class="keywordtype">void</span> put(<span class="keywordtype">size_t</span> index, <span class="keyword">const</span> T&amp; value)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">int</span> target_rank = get_target_rank(index);</div>
<div class="line">    <span class="keywordtype">size_t</span> local_index = get_local_index(index);</div>
<div class="line">    lci::status_t status;</div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">      status = lci::post_put_x(target_rank,</div>
<div class="line">                               <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(<span class="keyword">const_cast&lt;</span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>(&amp;value)),</div>
<div class="line">                               <span class="keyword">sizeof</span>(T), <a class="code hl_variable" href="../../d8/d33/group__LCI__BASIC.html#gafe52227fda9cf2b4026a3fd7925c2016">lci::COMP_NULL_RETRY</a>,</div>
<div class="line">                               local_index * <span class="keyword">sizeof</span>(T), m_rmrs[target_rank])</div>
<div class="line">                   .comp_semantic(<a class="code hl_enumvalue" href="../../d8/d33/group__LCI__BASIC.html#ggafb4a38b937767ee6f9104d94a1d777c2a91e02cd2b8621d0c05197f645668c5c4">lci::comp_semantic_t::network</a>)();</div>
<div class="line">      <a class="code hl_function" href="../../d5/dd3/namespacelci.html#ad55bf2fa3c43f989f8f382fa8c41a387">lci::progress</a>();</div>
<div class="line">    } <span class="keywordflow">while</span> (status.<a class="code hl_function" href="../../d9/d1e/structlci_1_1status__t.html#abaa9d395f7105a81a24bf3ec6b670643">is_retry</a>());</div>
<div class="line">    assert(status.<a class="code hl_function" href="../../d9/d1e/structlci_1_1status__t.html#a7d4d6335a16e1060b2cf8a03c767a3b7">is_done</a>());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">size_t</span> m_size;</div>
<div class="line">  <span class="keywordtype">size_t</span> m_per_rank_size;</div>
<div class="line">  <span class="keywordtype">size_t</span> m_local_start;</div>
<div class="line">  std::vector&lt;T&gt; m_data;</div>
<div class="line">  <span class="comment">// LCI memory registration information</span></div>
<div class="line">  lci::mr_t mr;</div>
<div class="line">  std::vector&lt;lci::rmr_t&gt; m_rmrs;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> get_target_rank(<span class="keywordtype">size_t</span> index)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    assert(index &lt; m_size);</div>
<div class="line">    <span class="keywordflow">return</span> index / m_per_rank_size;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">size_t</span> get_local_index(<span class="keywordtype">size_t</span> index)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    assert(index &lt; m_size);</div>
<div class="line">    <span class="keywordflow">return</span> index % m_per_rank_size;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> work(<span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">  distributed_array_t&lt;int&gt; darray(size, 0);</div>
<div class="line">  <span class="keywordtype">int</span> rank = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a9852426eb34e7849f5b6e1db60e49500">lci::get_rank_me</a>();</div>
<div class="line">  <span class="keywordtype">int</span> nranks = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a6e99f95e9b71b259ea5078c23d0ff4b9">lci::get_rank_n</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = rank; i &lt; size; i += nranks) {</div>
<div class="line">    darray.put(i, i);</div>
<div class="line">  }</div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#ae6054124daf3cd24d181b63ccbb7ce6c">lci::barrier</a>();</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = (rank + 1) % nranks; i &lt; size; i += nranks) {</div>
<div class="line">    <span class="keywordtype">int</span> value = darray.get(i);</div>
<div class="line">    assert(value == i);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** args)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> size = 1000;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#aee337a8c81cb3397461d8cd00a2d8f71">lci::g_runtime_init</a>();</div>
<div class="line">  work(size);</div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a701a29185fc4b076f1b8a198806fc615">lci::g_runtime_fina</a>();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__LCI__BASIC_html_gafe52227fda9cf2b4026a3fd7925c2016"><div class="ttname"><a href="../../d8/d33/group__LCI__BASIC.html#gafe52227fda9cf2b4026a3fd7925c2016">lci::COMP_NULL_RETRY</a></div><div class="ttdeci">const comp_t COMP_NULL_RETRY</div><div class="ttdoc">Special completion object setting allow_posted and allow_retry to false.</div><div class="ttdef"><b>Definition</b> lci.hpp:488</div></div>
<div class="ttc" id="agroup__LCI__BASIC_html_ggafb4a38b937767ee6f9104d94a1d777c2a91e02cd2b8621d0c05197f645668c5c4"><div class="ttname"><a href="../../d8/d33/group__LCI__BASIC.html#ggafb4a38b937767ee6f9104d94a1d777c2a91e02cd2b8621d0c05197f645668c5c4">lci::comp_semantic_t::network</a></div><div class="ttdeci">@ network</div><div class="ttdef"><b>Definition</b> lci.hpp:420</div></div>
<div class="ttc" id="anamespacelci_html_a24873f5ddc295cfc7f7a6109c0687788"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a24873f5ddc295cfc7f7a6109c0687788">lci::deregister_memory</a></div><div class="ttdeci">void deregister_memory(mr_t *mr_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2938</div></div>
<div class="ttc" id="anamespacelci_html_aaf51f7172447f6fb23b5f98f6e124ff9"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#aaf51f7172447f6fb23b5f98f6e124ff9">lci::register_memory</a></div><div class="ttdeci">mr_t register_memory(void *address_in, size_t size_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2901</div></div>
<div class="ttc" id="anamespacelci_html_ab6480639b459da398972da8c1f854646"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#ab6480639b459da398972da8c1f854646">lci::get_rmr</a></div><div class="ttdeci">rmr_t get_rmr(mr_t mr_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2975</div></div>
<div class="ttc" id="anamespacelci_html_acfab5281c6310f13d1a4c36fb164e89d"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#acfab5281c6310f13d1a4c36fb164e89d">lci::allgather</a></div><div class="ttdeci">void allgather(const void *sendbuf_in, void *recvbuf_in, size_t size_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2610</div></div>
</div><!-- fragment --> </details>
<details >
<summary >
Click to expand example output</summary>
<div class="fragment"><div class="line"># This example has no output.</div>
<div class="line">$ lcrun -n 4 ./lci_distributed_array</div>
</div><!-- fragment --> </details>
<h3><a class="anchor" id="autotoc_md76"></a>
Non-blocking Barrier</h3>
<p>This examples shows the usage of the completion graph and the send/recv operations to implement a non-blocking barrier.</p>
<details >
<summary >
Click to expand code</summary>
<div class="fragment"><div class="line"><span class="comment">// Copyright (c) 2025 The LCI Project Authors</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: NCSA</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;unistd.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d3/d33/lci_8hpp.html">lci.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// This examples shows the usage of the completion graph and the send/recv</span></div>
<div class="line"><span class="comment">// operations.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// create the graph according to the dissemination algorithm</span></div>
<div class="line"><a class="code hl_class" href="../../d1/da7/classlci_1_1comp__t.html">lci::comp_t</a> create_ibarrier_graph()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> rank_me = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a9852426eb34e7849f5b6e1db60e49500">lci::get_rank_me</a>();</div>
<div class="line">  <span class="keywordtype">int</span> rank_n = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a6e99f95e9b71b259ea5078c23d0ff4b9">lci::get_rank_n</a>();</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="../../d1/da7/classlci_1_1comp__t.html">lci::comp_t</a> <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8">graph</a> = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#aebd142b35d32f950515a5a35e4ac32d1">lci::alloc_graph</a>();</div>
<div class="line">  <span class="comment">// GRAPH_START is a special node that indicates the start of the graph.</span></div>
<div class="line">  <a class="code hl_typedef" href="../../d8/d33/group__LCI__BASIC.html#ga84f8522bb8dce688b8a246b6f923d64e">lci::graph_node_t</a> old_node = <a class="code hl_variable" href="../../d8/d33/group__LCI__BASIC.html#gad252b9870b3459000f93aaed9ba31a75">lci::GRAPH_START</a>;</div>
<div class="line">  <a class="code hl_typedef" href="../../d8/d33/group__LCI__BASIC.html#ga84f8522bb8dce688b8a246b6f923d64e">lci::graph_node_t</a> dummy_node;</div>
<div class="line">  <span class="comment">// The dissemination algorithm contains log2(rank_n) rounds.</span></div>
<div class="line">  <span class="comment">// In each round, each rank sends and receives a message to/from rank_me +/-</span></div>
<div class="line">  <span class="comment">// round**2.</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jump = 1; jump &lt; rank_n; jump *= 2) {</div>
<div class="line">    <span class="keywordtype">int</span> rank_to_recv = (rank_me - jump + rank_n) % rank_n;</div>
<div class="line">    <span class="keywordtype">int</span> rank_to_send = (rank_me + jump) % rank_n;</div>
<div class="line">    <span class="comment">// Define the communication operations for each round.</span></div>
<div class="line">    <span class="comment">// We cannot explicitly retry in the graph, so we set allow_retry to false.</span></div>
<div class="line">    <span class="comment">// The runtime will handle the retry using the internal backlog queues.</span></div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_enumvalue" href="../../d8/d33/group__LCI__BASIC.html#ggaca9c81007bfc7e1ddb44071f3aaaf400af701fee85540b78d08cb276d14953d58">recv</a> =</div>
<div class="line">        <a class="code hl_class" href="../../d7/df5/classlci_1_1post__recv__x.html">lci::post_recv_x</a>(rank_to_recv, <span class="keyword">nullptr</span>, 0, 0, <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8">graph</a>).<a class="code hl_function" href="../../d7/df5/classlci_1_1post__recv__x.html#a8ca868991d765fd27ad39a0f912d019c">allow_retry</a>(<span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_enumvalue" href="../../d8/d33/group__LCI__BASIC.html#ggaca9c81007bfc7e1ddb44071f3aaaf400a2541d938b0a58946090d7abdde0d3890">send</a> =</div>
<div class="line">        <a class="code hl_class" href="../../d6/de4/classlci_1_1post__send__x.html">lci::post_send_x</a>(rank_to_send, <span class="keyword">nullptr</span>, 0, 0, <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8">graph</a>).<a class="code hl_function" href="../../d6/de4/classlci_1_1post__send__x.html#a6befe5ff6cfde91858f4581fae6eb006">allow_retry</a>(<span class="keyword">false</span>);</div>
<div class="line">    <span class="comment">// Note that we do not trigger the operations here.</span></div>
<div class="line">    <span class="comment">// Instead, we make them as nodes in the graph.</span></div>
<div class="line">    <span class="keyword">auto</span> recv_node = <a class="code hl_function" href="../../d8/d33/group__LCI__BASIC.html#ga04913a1823ea2481cf7ba1284c7abc64">lci::graph_add_node_op</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8">graph</a>, <a class="code hl_enumvalue" href="../../d8/d33/group__LCI__BASIC.html#ggaca9c81007bfc7e1ddb44071f3aaaf400af701fee85540b78d08cb276d14953d58">recv</a>);</div>
<div class="line">    <span class="keyword">auto</span> send_node = <a class="code hl_function" href="../../d8/d33/group__LCI__BASIC.html#ga04913a1823ea2481cf7ba1284c7abc64">lci::graph_add_node_op</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8">graph</a>, <a class="code hl_enumvalue" href="../../d8/d33/group__LCI__BASIC.html#ggaca9c81007bfc7e1ddb44071f3aaaf400a2541d938b0a58946090d7abdde0d3890">send</a>);</div>
<div class="line">    <span class="comment">// To make the code more readable, we use a dummy node to represent the end</span></div>
<div class="line">    <span class="comment">// of the round.</span></div>
<div class="line">    <span class="keywordflow">if</span> (jump * 2 &gt;= rank_n) {</div>
<div class="line">      <span class="comment">// this is the last round</span></div>
<div class="line">      <span class="comment">// GRAPH_END is a special node that indicates the end of the graph.</span></div>
<div class="line">      dummy_node = <a class="code hl_variable" href="../../d5/dd3/namespacelci.html#a3173b3b86ebd54f0966ba7abd7e1646b">lci::GRAPH_END</a>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// we can make arbitrary functions as nodes in the graph</span></div>
<div class="line">      <span class="comment">// The graph expect the function of the node to either return `done` or</span></div>
<div class="line">      <span class="comment">// `posted`. In the case of `done`, the runtime will immeidately trigger</span></div>
<div class="line">      <span class="comment">// its children. In the case of `posted`, the runtime will do nothing and</span></div>
<div class="line">      <span class="comment">// the node will be considered pending until</span></div>
<div class="line">      <span class="comment">// `graph_node_mark_complete(node)` is called.</span></div>
<div class="line">      dummy_node = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#ac942e587d9dbca57c48e1ca3f3854969">graph_add_node</a>(</div>
<div class="line">          <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8">graph</a>, [](<span class="keywordtype">void</span>*) -&gt; <a class="code hl_struct" href="../../d9/d1e/structlci_1_1status__t.html">lci::status_t</a> { <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="../../d8/d33/group__LCI__BASIC.html#gga20db54161a501f6b62b3c9974d2013efa6b2ded51d81a4403d8a4bd25fa1e57ee">lci::errorcode_t::done</a>; });</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Specify the dependencies between the nodes.</span></div>
<div class="line">    <span class="comment">// Wait for the previous round to finish before starting this round.</span></div>
<div class="line">    <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a7ad5e9b11b95bc70fc8baac9992ef732">lci::graph_add_edge</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8">graph</a>, old_node, recv_node);</div>
<div class="line">    <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a7ad5e9b11b95bc70fc8baac9992ef732">lci::graph_add_edge</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8">graph</a>, old_node, send_node);</div>
<div class="line">    <span class="comment">// Wait for the send and recv operations to finish before moving to the next</span></div>
<div class="line">    <span class="comment">// round.</span></div>
<div class="line">    <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a7ad5e9b11b95bc70fc8baac9992ef732">lci::graph_add_edge</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8">graph</a>, recv_node, dummy_node);</div>
<div class="line">    <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a7ad5e9b11b95bc70fc8baac9992ef732">lci::graph_add_edge</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8">graph</a>, send_node, dummy_node);</div>
<div class="line">    old_node = dummy_node;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8">graph</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#aee337a8c81cb3397461d8cd00a2d8f71">lci::g_runtime_init</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// create a graph describing the operations needed by the barrier</span></div>
<div class="line">  <a class="code hl_class" href="../../d1/da7/classlci_1_1comp__t.html">lci::comp_t</a> <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8">graph</a> = create_ibarrier_graph();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// the graph can be reused</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d5/dd3/namespacelci.html#a9852426eb34e7849f5b6e1db60e49500">lci::get_rank_me</a>() == 0) {</div>
<div class="line">      <span class="comment">// create some asymmetric delay</span></div>
<div class="line">      sleep(1);</div>
<div class="line">    }</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;rank %d start barrier\n&quot;</span>, <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a9852426eb34e7849f5b6e1db60e49500">lci::get_rank_me</a>());</div>
<div class="line">    <span class="comment">// start executing those operations</span></div>
<div class="line">    <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a62817277dc599edc5864356a4192d312">lci::graph_start</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8">graph</a>);</div>
<div class="line">    <span class="comment">// wait for the operations to finish</span></div>
<div class="line">    <span class="keywordflow">while</span> (<a class="code hl_function" href="../../d5/dd3/namespacelci.html#a56809a72f78bbcf9e5fdd6d1ffebc58d">lci::graph_test</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8">graph</a>).is_retry()) {</div>
<div class="line">      <a class="code hl_function" href="../../d5/dd3/namespacelci.html#ad55bf2fa3c43f989f8f382fa8c41a387">lci::progress</a>();</div>
<div class="line">    }</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;rank %d end barrier\n&quot;</span>, <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a9852426eb34e7849f5b6e1db60e49500">lci::get_rank_me</a>());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// free the graph</span></div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a820947e1c3c281fa0510e66d5532a43c">lci::free_comp</a>(&amp;<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8">graph</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a701a29185fc4b076f1b8a198806fc615">lci::g_runtime_fina</a>();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclasslci_1_1post__recv__x_html_a8ca868991d765fd27ad39a0f912d019c"><div class="ttname"><a href="../../d7/df5/classlci_1_1post__recv__x.html#a8ca868991d765fd27ad39a0f912d019c">lci::post_recv_x::allow_retry</a></div><div class="ttdeci">post_recv_x &amp;&amp; allow_retry(bool allow_retry_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:2039</div></div>
<div class="ttc" id="aclasslci_1_1post__send__x_html"><div class="ttname"><a href="../../d6/de4/classlci_1_1post__send__x.html">lci::post_send_x</a></div><div class="ttdoc">The actual implementation for post_send.</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1919</div></div>
<div class="ttc" id="aclasslci_1_1post__send__x_html_a6befe5ff6cfde91858f4581fae6eb006"><div class="ttname"><a href="../../d6/de4/classlci_1_1post__send__x.html#a6befe5ff6cfde91858f4581fae6eb006">lci::post_send_x::allow_retry</a></div><div class="ttdeci">post_send_x &amp;&amp; allow_retry(bool allow_retry_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1960</div></div>
<div class="ttc" id="agroup__LCI__BASIC_html_ga04913a1823ea2481cf7ba1284c7abc64"><div class="ttname"><a href="../../d8/d33/group__LCI__BASIC.html#ga04913a1823ea2481cf7ba1284c7abc64">lci::graph_add_node_op</a></div><div class="ttdeci">graph_node_t graph_add_node_op(comp_t graph, const T &amp;op)</div><div class="ttdoc">Add a functor as a node to the completion graph.</div><div class="ttdef"><b>Definition</b> lci.hpp:656</div></div>
<div class="ttc" id="agroup__LCI__BASIC_html_ga84f8522bb8dce688b8a246b6f923d64e"><div class="ttname"><a href="../../d8/d33/group__LCI__BASIC.html#ga84f8522bb8dce688b8a246b6f923d64e">lci::graph_node_t</a></div><div class="ttdeci">void * graph_node_t</div><div class="ttdoc">The node type for the completion graph.</div><div class="ttdef"><b>Definition</b> lci.hpp:536</div></div>
<div class="ttc" id="agroup__LCI__BASIC_html_gad252b9870b3459000f93aaed9ba31a75"><div class="ttname"><a href="../../d8/d33/group__LCI__BASIC.html#gad252b9870b3459000f93aaed9ba31a75">lci::GRAPH_START</a></div><div class="ttdeci">const graph_node_t GRAPH_START</div><div class="ttdoc">The start node of the completion graph.</div><div class="ttdef"><b>Definition</b> lci.hpp:542</div></div>
<div class="ttc" id="agroup__LCI__BASIC_html_gga20db54161a501f6b62b3c9974d2013efa6b2ded51d81a4403d8a4bd25fa1e57ee"><div class="ttname"><a href="../../d8/d33/group__LCI__BASIC.html#gga20db54161a501f6b62b3c9974d2013efa6b2ded51d81a4403d8a4bd25fa1e57ee">lci::errorcode_t::done</a></div><div class="ttdeci">@ done</div><div class="ttdef"><b>Definition</b> lci.hpp:121</div></div>
<div class="ttc" id="agroup__LCI__BASIC_html_ggaca9c81007bfc7e1ddb44071f3aaaf400a2541d938b0a58946090d7abdde0d3890"><div class="ttname"><a href="../../d8/d33/group__LCI__BASIC.html#ggaca9c81007bfc7e1ddb44071f3aaaf400a2541d938b0a58946090d7abdde0d3890">lci::matching_entry_type_t::send</a></div><div class="ttdeci">@ send</div><div class="ttdef"><b>Definition</b> lci.hpp:384</div></div>
<div class="ttc" id="agroup__LCI__BASIC_html_ggaca9c81007bfc7e1ddb44071f3aaaf400af701fee85540b78d08cb276d14953d58"><div class="ttname"><a href="../../d8/d33/group__LCI__BASIC.html#ggaca9c81007bfc7e1ddb44071f3aaaf400af701fee85540b78d08cb276d14953d58">lci::matching_entry_type_t::recv</a></div><div class="ttdeci">@ recv</div><div class="ttdef"><b>Definition</b> lci.hpp:385</div></div>
<div class="ttc" id="anamespacelci_html_a3173b3b86ebd54f0966ba7abd7e1646b"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a3173b3b86ebd54f0966ba7abd7e1646b">lci::GRAPH_END</a></div><div class="ttdeci">const graph_node_t GRAPH_END</div><div class="ttdef"><b>Definition</b> lci.hpp:543</div></div>
<div class="ttc" id="anamespacelci_html_a56809a72f78bbcf9e5fdd6d1ffebc58d"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a56809a72f78bbcf9e5fdd6d1ffebc58d">lci::graph_test</a></div><div class="ttdeci">status_t graph_test(comp_t comp_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1712</div></div>
<div class="ttc" id="anamespacelci_html_a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bbaf8b0b924ebd7046dbfa85a856e4682c8">lci::attr_comp_type_t::graph</a></div><div class="ttdeci">@ graph</div><div class="ttdef"><b>Definition</b> lci_binding_pre.hpp:38</div></div>
<div class="ttc" id="anamespacelci_html_a62817277dc599edc5864356a4192d312"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a62817277dc599edc5864356a4192d312">lci::graph_start</a></div><div class="ttdeci">void graph_start(comp_t comp_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1675</div></div>
<div class="ttc" id="anamespacelci_html_a7ad5e9b11b95bc70fc8baac9992ef732"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#a7ad5e9b11b95bc70fc8baac9992ef732">lci::graph_add_edge</a></div><div class="ttdeci">void graph_add_edge(comp_t comp_in, graph_node_t src_in, graph_node_t dst_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1598</div></div>
<div class="ttc" id="anamespacelci_html_ac942e587d9dbca57c48e1ca3f3854969"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#ac942e587d9dbca57c48e1ca3f3854969">lci::graph_add_node</a></div><div class="ttdeci">graph_node_t graph_add_node(comp_t comp_in, graph_node_run_cb_t fn_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1552</div></div>
<div class="ttc" id="anamespacelci_html_aebd142b35d32f950515a5a35e4ac32d1"><div class="ttname"><a href="../../d5/dd3/namespacelci.html#aebd142b35d32f950515a5a35e4ac32d1">lci::alloc_graph</a></div><div class="ttdeci">comp_t alloc_graph()</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1506</div></div>
</div><!-- fragment --> </details>
<details >
<summary >
Click to expand example output</summary>
<div class="fragment"><div class="line">$ lcrun -n 4 ./lci_nonblocking_barrier </div>
<div class="line">rank 1 start barrier</div>
<div class="line">rank 2 start barrier</div>
<div class="line">rank 3 start barrier</div>
<div class="line">rank 0 start barrier</div>
<div class="line">rank 0 end barrier</div>
<div class="line">rank 1 end barrier</div>
<div class="line">rank 1 start barrier</div>
<div class="line">rank 3 end barrier</div>
<div class="line">rank 3 start barrier</div>
<div class="line">rank 0 start barrier</div>
<div class="line">rank 2 end barrier</div>
<div class="line">rank 2 start barrier</div>
<div class="line">rank 2 end barrier</div>
<div class="line">rank 2 start barrier</div>
<div class="line">rank 0 end barrier</div>
<div class="line">rank 3 end barrier</div>
<div class="line">rank 3 start barrier</div>
<div class="line">rank 1 end barrier</div>
<div class="line">rank 1 start barrier</div>
<div class="line">rank 0 start barrier</div>
<div class="line">rank 1 end barrier</div>
<div class="line">rank 0 end barrier</div>
<div class="line">rank 2 end barrier</div>
<div class="line">rank 3 end barrier</div>
</div><!-- fragment --> </details>
<h3><a class="anchor" id="autotoc_md77"></a>
Multithreaded Active Message Ping-pong</h3>
<p>This example shows the usages of thread-local devices to speedup the active message communication in a multithreaded environment.</p>
<details >
<summary >
Click to expand code</summary>
<div class="fragment"><div class="line"><span class="comment">// Copyright (c) 2025 The LCI Project Authors</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: NCSA</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;lct.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d3/d33/lci_8hpp.html">lci.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// This example shows the usages of thread-local devices.</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> nthreads = 4;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> nmsgs = 1000;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> msg_size = 8;</div>
<div class="line"> </div>
<div class="line">LCT_tbarrier_t thread_barrier;</div>
<div class="line">std::atomic&lt;int&gt; thread_seqence_control(0);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> worker(<span class="keywordtype">int</span> thread_id)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> rank = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a9852426eb34e7849f5b6e1db60e49500">lci::get_rank_me</a>();</div>
<div class="line">  <span class="keywordtype">int</span> nranks = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a6e99f95e9b71b259ea5078c23d0ff4b9">lci::get_rank_n</a>();</div>
<div class="line">  <span class="keywordtype">int</span> peer_rank;</div>
<div class="line">  <span class="keywordflow">if</span> (nranks == 1) {</div>
<div class="line">    peer_rank = rank;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    peer_rank = (rank + nranks / 2) % nranks;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// allocate resouces</span></div>
<div class="line">  <span class="comment">// device and rcomp allocation needs to be synchronized to ensure uniformity</span></div>
<div class="line">  <span class="comment">// across ranks.</span></div>
<div class="line">  <span class="keywordflow">while</span> (thread_seqence_control != thread_id) <span class="keywordflow">continue</span>;</div>
<div class="line">  <a class="code hl_class" href="../../d1/da7/classlci_1_1comp__t.html">lci::comp_t</a> <a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba1c29ac0ab69660bfc944d1a913ecda64">cq</a> = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a6f475a6e5ce001cca691795999bdb46f">lci::alloc_cq</a>();</div>
<div class="line">  <a class="code hl_typedef" href="../../d8/d33/group__LCI__BASIC.html#gacd46beb25126ebb7bf83b33e6381d6d2">lci::rcomp_t</a> rcomp = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a7952c7d36886b256a2c4d9be1f63aa47">lci::register_rcomp</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba1c29ac0ab69660bfc944d1a913ecda64">cq</a>);</div>
<div class="line">  <a class="code hl_class" href="../../d6/d66/classlci_1_1device__t.html">lci::device_t</a> device = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a1b2bde330a483b62792ab033887af4ab">lci::alloc_device</a>();</div>
<div class="line">  <span class="keywordflow">if</span> (++thread_seqence_control == nthreads) thread_seqence_control = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span>* send_buf = malloc(msg_size);</div>
<div class="line">  memset(send_buf, rank, msg_size);</div>
<div class="line"> </div>
<div class="line">  LCT_tbarrier_arrive_and_wait(thread_barrier);</div>
<div class="line">  <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">  <span class="keywordflow">if</span> (nranks == 1 || rank &lt; nranks / 2) {</div>
<div class="line">    <span class="comment">// sender</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nmsgs; i++) {</div>
<div class="line">      <span class="comment">// send a message</span></div>
<div class="line">      <a class="code hl_class" href="../../d2/ddb/classlci_1_1post__am__x.html">lci::post_am_x</a>(peer_rank, send_buf, msg_size, <a class="code hl_variable" href="../../d8/d33/group__LCI__BASIC.html#gadacc63597d846dd225a8c8e0b9e395f8">lci::COMP_NULL</a>, rcomp)</div>
<div class="line">          .<a class="code hl_function" href="../../d2/ddb/classlci_1_1post__am__x.html#ad6c306765380107207fab8aa45ad4527">device</a>(device)</div>
<div class="line">          .<a class="code hl_function" href="../../d2/ddb/classlci_1_1post__am__x.html#a4c83ce67927a5be8e3ab827e601c0c64">tag</a>(thread_id)();</div>
<div class="line">      <span class="comment">// wait for an incoming message</span></div>
<div class="line">      <a class="code hl_struct" href="../../d9/d1e/structlci_1_1status__t.html">lci::status_t</a> status;</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        <a class="code hl_class" href="../../df/dd2/classlci_1_1progress__x.html">lci::progress_x</a>().<a class="code hl_function" href="../../df/dd2/classlci_1_1progress__x.html#a48c1029e1e0f41f220ae43586fba5d1b">device</a>(device)();</div>
<div class="line">        status = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a5a9a377509b16d786a6c4fb879b91677">lci::cq_pop</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba1c29ac0ab69660bfc944d1a913ecda64">cq</a>);</div>
<div class="line">      } <span class="keywordflow">while</span> (status.<a class="code hl_function" href="../../d9/d1e/structlci_1_1status__t.html#abaa9d395f7105a81a24bf3ec6b670643">is_retry</a>());</div>
<div class="line">      <span class="keywordflow">if</span> (status.<a class="code hl_variable" href="../../d9/d1e/structlci_1_1status__t.html#a5e89438bfd4000416ab88cb01059c398">tag</a> != thread_id) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;thread_id: &quot;</span> &lt;&lt; thread_id</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, status.tag: &quot;</span> &lt;&lt; status.<a class="code hl_variable" href="../../d9/d1e/structlci_1_1status__t.html#a5e89438bfd4000416ab88cb01059c398">tag</a> &lt;&lt; std::endl;</div>
<div class="line">      }</div>
<div class="line">      assert(status.<a class="code hl_variable" href="../../d9/d1e/structlci_1_1status__t.html#a5e89438bfd4000416ab88cb01059c398">tag</a> == thread_id);</div>
<div class="line">      assert(status.<a class="code hl_variable" href="../../d9/d1e/structlci_1_1status__t.html#a723483ab2c1145824fc16a44a44b1997">size</a> == msg_size);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; msg_size; j++) {</div>
<div class="line">        assert(((<span class="keywordtype">char</span>*)status.<a class="code hl_variable" href="../../d9/d1e/structlci_1_1status__t.html#a831eecf0a79ddc81724fc813148bcfd3">buffer</a>)[j] == peer_rank);</div>
<div class="line">      }</div>
<div class="line">      free(status.<a class="code hl_variable" href="../../d9/d1e/structlci_1_1status__t.html#a831eecf0a79ddc81724fc813148bcfd3">buffer</a>);</div>
<div class="line">    }</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// receiver</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nmsgs; i++) {</div>
<div class="line">      <span class="comment">// wait for an incoming message</span></div>
<div class="line">      <a class="code hl_struct" href="../../d9/d1e/structlci_1_1status__t.html">lci::status_t</a> status;</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        <a class="code hl_class" href="../../df/dd2/classlci_1_1progress__x.html">lci::progress_x</a>().<a class="code hl_function" href="../../df/dd2/classlci_1_1progress__x.html#a48c1029e1e0f41f220ae43586fba5d1b">device</a>(device)();</div>
<div class="line">        status = <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a5a9a377509b16d786a6c4fb879b91677">lci::cq_pop</a>(<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba1c29ac0ab69660bfc944d1a913ecda64">cq</a>);</div>
<div class="line">      } <span class="keywordflow">while</span> (status.<a class="code hl_function" href="../../d9/d1e/structlci_1_1status__t.html#abaa9d395f7105a81a24bf3ec6b670643">is_retry</a>());</div>
<div class="line">      assert(status.<a class="code hl_variable" href="../../d9/d1e/structlci_1_1status__t.html#a5e89438bfd4000416ab88cb01059c398">tag</a> == thread_id);</div>
<div class="line">      assert(status.<a class="code hl_variable" href="../../d9/d1e/structlci_1_1status__t.html#a723483ab2c1145824fc16a44a44b1997">size</a> == msg_size);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; msg_size; j++) {</div>
<div class="line">        assert(((<span class="keywordtype">char</span>*)status.<a class="code hl_variable" href="../../d9/d1e/structlci_1_1status__t.html#a831eecf0a79ddc81724fc813148bcfd3">buffer</a>)[j] == peer_rank);</div>
<div class="line">      }</div>
<div class="line">      free(status.<a class="code hl_variable" href="../../d9/d1e/structlci_1_1status__t.html#a831eecf0a79ddc81724fc813148bcfd3">buffer</a>);</div>
<div class="line">      <span class="comment">// send a message</span></div>
<div class="line">      <a class="code hl_class" href="../../d2/ddb/classlci_1_1post__am__x.html">lci::post_am_x</a>(peer_rank, send_buf, msg_size, <a class="code hl_variable" href="../../d8/d33/group__LCI__BASIC.html#gadacc63597d846dd225a8c8e0b9e395f8">lci::COMP_NULL</a>, rcomp)</div>
<div class="line">          .<a class="code hl_function" href="../../d2/ddb/classlci_1_1post__am__x.html#ad6c306765380107207fab8aa45ad4527">device</a>(device)</div>
<div class="line">          .<a class="code hl_function" href="../../d2/ddb/classlci_1_1post__am__x.html#a4c83ce67927a5be8e3ab827e601c0c64">tag</a>(thread_id)();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  LCT_tbarrier_arrive_and_wait(thread_barrier);</div>
<div class="line">  <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">  <span class="keywordflow">if</span> (thread_id == 0 &amp;&amp; rank == 0) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;pingpong_am_mt: &quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of threads: &quot;</span> &lt;&lt; nthreads &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of messages: &quot;</span> &lt;&lt; nmsgs &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Message size: &quot;</span> &lt;&lt; msg_size &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of ranks: &quot;</span> &lt;&lt; nranks &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordtype">double</span> total_time_us =</div>
<div class="line">        std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start)</div>
<div class="line">            .count();</div>
<div class="line">    <span class="keywordtype">double</span> msg_rate_uni =</div>
<div class="line">        1.0 * nmsgs * nthreads * (nranks + 1) / 2 / total_time_us;</div>
<div class="line">    <span class="keywordtype">double</span> bandwidth_uni = msg_rate_uni * msg_size;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Total time: &quot;</span> &lt;&lt; total_time_us / 1e6 &lt;&lt; <span class="stringliteral">&quot; s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Message rate: &quot;</span> &lt;&lt; msg_rate_uni &lt;&lt; <span class="stringliteral">&quot; mmsg/s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Bandwidth: &quot;</span> &lt;&lt; bandwidth_uni &lt;&lt; <span class="stringliteral">&quot; MB/s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  free(send_buf);</div>
<div class="line">  <span class="comment">// free resouces</span></div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a820947e1c3c281fa0510e66d5532a43c">lci::free_comp</a>(&amp;<a class="code hl_enumvalue" href="../../d5/dd3/namespacelci.html#a610912d197faa01c2f04666209b814bba1c29ac0ab69660bfc944d1a913ecda64">cq</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span> (thread_seqence_control != thread_id) {</div>
<div class="line">    <a class="code hl_class" href="../../df/dd2/classlci_1_1progress__x.html">lci::progress_x</a>().<a class="code hl_function" href="../../df/dd2/classlci_1_1progress__x.html#a48c1029e1e0f41f220ae43586fba5d1b">device</a>(device)();</div>
<div class="line">  }</div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a81de742f5f381d60736552db6ed6572a">lci::free_device</a>(&amp;device);</div>
<div class="line">  <span class="keywordflow">if</span> (++thread_seqence_control == nthreads) thread_seqence_control = 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** args)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Initialize the global default runtime.</span></div>
<div class="line">  <span class="comment">// Here we use the *objectized flexible function* version of the</span></div>
<div class="line">  <span class="comment">// `g_runtime_init` operation and specify that the default device should not</span></div>
<div class="line">  <span class="comment">// be allocated.</span></div>
<div class="line">  <a class="code hl_class" href="../../d1/dcd/classlci_1_1g__runtime__init__x.html">lci::g_runtime_init_x</a>().<a class="code hl_function" href="../../d1/dcd/classlci_1_1g__runtime__init__x.html#ad72fab3463ebf56743a418966751b9cc">alloc_default_device</a>(<span class="keyword">false</span>)();</div>
<div class="line">  <span class="comment">// After at least one runtime is active, we can query the rank and nranks.</span></div>
<div class="line">  <span class="comment">// rank is the id of the current process</span></div>
<div class="line">  <span class="comment">// nranks is the total number of the processes in the current job.</span></div>
<div class="line">  assert(<a class="code hl_function" href="../../d5/dd3/namespacelci.html#a6e99f95e9b71b259ea5078c23d0ff4b9">lci::get_rank_n</a>() == 1 || <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a6e99f95e9b71b259ea5078c23d0ff4b9">lci::get_rank_n</a>() % 2 == 0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// get a thread barrier</span></div>
<div class="line">  thread_barrier = LCT_tbarrier_alloc(nthreads);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// spawn the threads to do the pingpong</span></div>
<div class="line">  <span class="keywordflow">if</span> (nthreads == 1) {</div>
<div class="line">    worker(0);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    std::vector&lt;std::thread&gt; threads;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nthreads; i++) {</div>
<div class="line">      threads.push_back(std::thread(worker, i));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; thread : threads) {</div>
<div class="line">      thread.join();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// free the thread barrier</span></div>
<div class="line">  LCT_tbarrier_free(&amp;thread_barrier);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Finalize the global default runtime</span></div>
<div class="line">  <a class="code hl_function" href="../../d5/dd3/namespacelci.html#a701a29185fc4b076f1b8a198806fc615">lci::g_runtime_fina</a>();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclasslci_1_1g__runtime__init__x_html"><div class="ttname"><a href="../../d1/dcd/classlci_1_1g__runtime__init__x.html">lci::g_runtime_init_x</a></div><div class="ttdoc">The actual implementation for g_runtime_init.</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:181</div></div>
<div class="ttc" id="aclasslci_1_1g__runtime__init__x_html_ad72fab3463ebf56743a418966751b9cc"><div class="ttname"><a href="../../d1/dcd/classlci_1_1g__runtime__init__x.html#ad72fab3463ebf56743a418966751b9cc">lci::g_runtime_init_x::alloc_default_device</a></div><div class="ttdeci">g_runtime_init_x &amp;&amp; alloc_default_device(bool alloc_default_device_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:198</div></div>
<div class="ttc" id="aclasslci_1_1post__am__x_html"><div class="ttname"><a href="../../d2/ddb/classlci_1_1post__am__x.html">lci::post_am_x</a></div><div class="ttdoc">The actual implementation for post_am.</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1839</div></div>
<div class="ttc" id="aclasslci_1_1post__am__x_html_a4c83ce67927a5be8e3ab827e601c0c64"><div class="ttname"><a href="../../d2/ddb/classlci_1_1post__am__x.html#a4c83ce67927a5be8e3ab827e601c0c64">lci::post_am_x::tag</a></div><div class="ttdeci">post_am_x &amp;&amp; tag(tag_t tag_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1874</div></div>
<div class="ttc" id="aclasslci_1_1post__am__x_html_ad6c306765380107207fab8aa45ad4527"><div class="ttname"><a href="../../d2/ddb/classlci_1_1post__am__x.html#ad6c306765380107207fab8aa45ad4527">lci::post_am_x::device</a></div><div class="ttdeci">post_am_x &amp;&amp; device(device_t device_in)</div><div class="ttdef"><b>Definition</b> lci_binding_post.hpp:1870</div></div>
<div class="ttc" id="agroup__LCI__BASIC_html_gadacc63597d846dd225a8c8e0b9e395f8"><div class="ttname"><a href="../../d8/d33/group__LCI__BASIC.html#gadacc63597d846dd225a8c8e0b9e395f8">lci::COMP_NULL</a></div><div class="ttdeci">const comp_t COMP_NULL</div><div class="ttdoc">Special completion object setting allow_posted to false.</div><div class="ttdef"><b>Definition</b> lci.hpp:474</div></div>
<div class="ttc" id="astructlci_1_1status__t_html_a5e89438bfd4000416ab88cb01059c398"><div class="ttname"><a href="../../d9/d1e/structlci_1_1status__t.html#a5e89438bfd4000416ab88cb01059c398">lci::status_t::tag</a></div><div class="ttdeci">tag_t tag</div><div class="ttdef"><b>Definition</b> lci.hpp:448</div></div>
</div><!-- fragment --> </details>
<details >
<summary >
Click to expand example output (Run on my laptop. Performance may vary.)</summary>
<div class="fragment"><div class="line">$ lcrun -n 4 ./lci_pingpong_am_mt </div>
<div class="line">pingpong_am_mt: </div>
<div class="line">Number of threads: 4</div>
<div class="line">Number of messages: 1000</div>
<div class="line">Message size: 8 bytes</div>
<div class="line">Number of ranks: 4</div>
<div class="line">Total time: 0.035286 s</div>
<div class="line">Message rate: 0.283399 mmsg/s</div>
<div class="line">Bandwidth: 2.26719 MB/s</div>
</div><!-- fragment --> </details>
<h1><a class="anchor" id="autotoc_md78"></a>
Run LCI applications</h1>
<p>In <a class="el" href="../../d2/dcd/quickstart.html">Quick Start</a>, we have shown you how to run LCI applications using <code>mpirun</code> or <code>srun</code>. Here, we will discuss the bootstrapping process in more detail.</p>
<p>To successfully bootstrap LCI, the launcher (<code>srun</code>, <code>mpirun</code>, or <code>lcrun</code>) must match the bootstrapping backend used by LCI. Normally, LCI will automatically select the right bootstrapping backend based on the environment so no special configuration is needed. However, if you see your applications were launched as a collection of processes all with rank 0, it means something went wrong.</p>
<h3><a class="anchor" id="autotoc_md79"></a>
Run LCI applications with lcrun</h3>
<p>You do not need to do anything special to run LCI applications with <code>lcrun</code>. However, <code>lcrun</code> is a "toy" launcher that is not as scalable as <code>srun</code> or <code>mpirun</code>. It is mainly used for testing and debugging purposes.</p>
<p>If you ever encounter a problem with <code>lcrun</code>, you can remove the temporary folder <code>~/.tmp/lct_pmi_file-*</code> and try again.</p>
<h3><a class="anchor" id="autotoc_md80"></a>
Run LCI applications with srun</h3>
<p>LCI is shipped with a copy of the SLURM PMI1 and PMI2 client implementation, so normally you can use <code>srun</code> to run LCI applications without any extra configuration. You may need to explicitly enable the pmi2 support by <code>srun --mpi=pmi2</code>.</p>
<p>On Cray systems, you may need to load the <code>cray-pmi</code> module before building LCI as <code>srun</code> on some Cray systems only supports Cray PMI.</p>
<h3><a class="anchor" id="autotoc_md81"></a>
Run LCI applications with mpirun</h3>
<p>Because there are many different MPI implementations and there are no standard about how they implement <code>mpirun</code>, it is slightly more complicated to run LCI applications with <code>mpirun</code>. In such cases, the easiest way is to let LCI use MPI to bootstrap. You just need to set the CMake variable <code>LCT_PMI_BACKEND_ENABLE_MPI=ON</code> and link LCI to MPI.</p>
<p>It is possible to directly use the PMI backend with <code>mpirun</code>, but you need to find the corresponding PMI client library and link LCI to it. Read the following section for more details.</p>
<h2><a class="anchor" id="autotoc_md82"></a>
More details</h2>
<h3><a class="anchor" id="autotoc_md83"></a>
Bootstrapping backends</h3>
<p>Specifically, LCI has six different bootstrapping backends:</p><ul>
<li><code>pmi1</code>: Process Management Interface version 1.</li>
<li><code>pmi2</code>: Process Management Interface version 2.</li>
<li><code>pmix</code>: Process Management Interface X.</li>
<li><code>mpi</code>: Use MPI to bootstrap LCI.</li>
<li><code>file</code>: LCI-specific bootstrapping backend with a shared file system and <code>flock</code>.</li>
<li><code>local</code>: Just set <code>rank_me</code> to 0 and <code>rank_n</code> to 1.</li>
</ul>
<p><code>pmi1</code>, <code>pmi2</code>, and <code>pmix</code> are the recommended backends to use. They are the same backends used by MPI. The <code>mpi</code> backend is a fallback option if you cannot find the PMI client library. The <code>file</code> backend is a non-scalable bootstrapping backend mainly for testing and debugging purposes.</p>
<p>By default, the source code of LCI is shipped with a copy of the SLURM PMI1 and PMI2 client implementation, so <code>pmi1</code> and <code>pmi2</code> are always compiled. <code>pmix</code> will be compiled if the CMake configuration of LCI finds the PMIx client library. The <code>mpi</code> backend must be explicitly asked for by setting the CMake variable <code>LCT_PMI_BACKEND_ENABLE_MPI=ON</code>. The <code>file</code> and <code>local</code> backend is always compiled.</p>
<p>However, the SLURM PMI1 and PMI2 client implementation is not always the best option. For example, if you are using <code>mpirun</code>, you may want to use the PMI client library that comes with your MPI implementation. In this case, you need to find the corresponding PMI client library and link LCI to it. <code>ldd $(which mpirun)</code> will show you the PMI client library used by <code>mpirun</code>. Normally, MPICH uses <code>hydra-pmi</code>; Cray-MPICH uses <code>cray-pmi</code>; OpenMPI uses <code>pmix</code>. After finding the PMI client library, you can reconfigure LCI with the corresponding PMI client library through the <code>PMI_ROOT</code>, <code>PMI2_ROOT</code>, or <code>PMIx_ROOT</code> environment/cmake variables.</p>
<p>A CMake variable <code>LCT_PMI_BACKEND_DEFAULT</code> and an environment variable <code>LCT_PMI_BACKEND</code> can be used to set a list of backends to try in order (if they are compiled). The first one that works will be used. The default value is <code>pmi1,pmi2,pmix,mpi,file,local</code>.</p>
<p>You can use <code>export LCT_LOG_LEVEL=info</code> to monitor the bootstrapping procedure.</p>
<h3><a class="anchor" id="autotoc_md84"></a>
Launchers</h3>
<p><code>srun</code> and <code>mpirun</code> should use one of the PMI backends (or <code>mpi</code> as a last resort). <code>lcrun</code> will use the <code>file</code> backend.</p>
<p>Depending on the SLURM configuration, <code>srun</code> may not enable PMI by default. In this case, you can explicitly enable one of the PMI services by using the <code>--mpi</code> option. <code>srun --mpi=list -n 1 hostname</code> will show you the available PMI services. You can confirm whether the PMI service has been enabled with <code>srun env | grep PMI</code>.</p>
<p><code>mpirun</code> will use the PMI client library that comes with your MPI implementation. As mentioned above, you need to link LCI to the correct PMI client library.</p>
<p>Sometimes, <code>lcrun</code> may hang because of a previous failed run. In this case, you can remove the temporary folder <code>~/.tmp/lct_pmi_file-*</code> and try again.</p>
<h3><a class="anchor" id="autotoc_md85"></a>
More about the file backend</h3>
<p>The <code>file</code> backend allows you to launch multiple LCI processes individually without a launcher. This can significantly ease the debugging process.</p>
<p>For example, you can open two terminal windows and run the following commands in each window: </p><div class="fragment"><div class="line">export LCT_PMI_BACKEND=file</div>
<div class="line">export LCT_PMI_FILE_NRANKS=2</div>
<div class="line">./lci_program</div>
<div class="line"># or launch it with gdb</div>
<div class="line">gdb ./lci_program</div>
</div><!-- fragment --><p> This will launch two LCI processes with rank 0 and rank 1. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
